# 二分算法 第一节

**Published:** October 14, 2025
**Category:** Programming
**Read Time:** 8 min

二分是一个能让人充分感受到算法魅力的 first glance，今天我们从最基础的二分一路直上云霄！

## 经典二分查找
二分查找是最基础的二分算法，用于在**有序**数组中查找特定元素。
- 每次都将搜索区间一分为二
- 中值比较，确定下一次的搜索区间
- 用递归更为方便
- 时间复杂度O(log n)

下面是一个经典模板：
``` python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1  # 未找到
```
狗都能学会，你就学吧你就

## 二分答案
这是一个非常聪明的技巧！它的思想时当你想解决一个问题的时候，你对它的答案做二分。就像是不断地问自己，如果这题答案是5，计算发现`唔，应该比5大`，再进一步二分下一个搜索空间。对特定的一些问题，通常是求解**最大值最小**和**最小值最大**的问题时有效，因为这些问题可以提供二分中选择左区间还是右区间的判断。通常，这意味着求一个临界点。

这种算法的代码模板:
``` python
def binary_search_answer(left, right, check_func):
    while left < right:
        mid = (left + right + 1) // 2  # 向上取整，避免死循环
        
        if check_func(mid):
            left = mid  # 尝试更大的值
        else:
            right = mid - 1  # 缩小范围
    
    return left
```
其中的 `check_func()` 函数用来根据题目要求判断上下区间，返回 bool 变量。

我们用一个实例帮助理解：

### 吃香蕉问题（LeetCode 875）

#### 题目描述
有 `n` 堆香蕉，第 `i` 堆有 `piles[i]` 根香蕉。守卫每小时会回来，你必须在 `h` 小时内吃完所有香蕉。

每小时你可以选择一堆香蕉，吃掉 `k` 根（k是你选择的速度）。如果你选择的速度是 `k`，那么：
- 对于一堆有 `x` 根香蕉，你需要 `ceil(x / k)` 小时吃完这堆

问：最小的速度 `k` 是多少，才能在 `h` 小时内吃完所有香蕉？

PS：`ceil()`函数在`math`库中，表示向上取整

#### 示例
```
输入: piles = [3,6,7,11], h = 8
输出: 4
解释: 当速度k=4时：
- 第1堆：ceil(3/4) = 1小时
- 第2堆：ceil(6/4) = 2小时
- 第3堆：ceil(7/4) = 2小时
- 第4堆：ceil(11/4) = 3小时
总计8小时，恰好能在8小时内吃完
```
#### 分析！
乍一看，这题死活和二分扯不上关系，但是你敏锐地察觉到，要求的似乎是一个**临界点**，当然你可以吃很快的速度，秒了所有香蕉，但是你想优雅地在h小时内正好吃完它们，这就满足了二分答案的条件。
你咂咂嘴，嗯~，那想一想如果我猜测我用速度`k1`吃它，我如何判断我接下来要搜索的速度范围时比`k1`大还是小呢？  
你恍然大悟！如果h小时吃不完就说明吃的太慢，在比`k1`大的速度区间内二分。吃得完就说明不够优雅，去比`k1`小的速度区间二分。  
*bingo*
接下来要解决的就是答案范围，要对哪个范围进行初始的二分呢？可能的速度最大值和最小值是什么呢？  
众所周知，一小时不能吃半根香蕉，于是最小值是`1`  
又因为你每次只能吃某一堆（不能一小时内吃完这堆吃那堆），所以最大值是`max(piles)`。因为再大也没有意义了。  
现在你的《二分答案心经》已修至小成，一个区区《香蕉掌法》的武决岂不是轻松拿下？
#### 《香蕉掌法》

```python
import math

def min_eating_speed(piles, h):
    def can_eat_all(speed):
        total_hours = 0
        for pile in piles:
            total_hours += math.ceil(pile / speed)
        return total_hours <= h
    
    # 二分答案范围
    left, right = 1, max(piles)
    
    while left < right:
        mid = (left + right) // 2
        
        if can_eat_all(mid):
            # 能吃完，尝试更小的速度
            right = mid
        else:
            # 吃不完，需要更大的速度
            left = mid + 1
    
    return left
```
神功已成，亟需出门游历，可以看看[洛谷-二分竞技场](https://www.luogu.com.cn/training/111)继续锻炼此二门神妙法则！在这里再分享一道更难的题
### 数列分段 （Luogu P1182）
#### 题目描述
对于一个长度为N的正整数数列，要求分为M段，每段连续，且每段和的最大值最小。

如数列`[4, 2, 4, 5, 1]`要分成`3`段，分成`[4, 2], [4, 5], [1]`时和的最大值是9，而分成`[4], [2, 4], [5, 1]`时和的最大值只有6。后者是更好的分段方法，也是题目的答案。

输入第一行N，M。第二行包含N个非负整数，组成一个数列。
输出一个正整数表示答案。
#### 题目分析！
题目输出不要求给出分组方法，而且题目很明确地说了**最大值最小**，你惊坐起！  
我们来构建二分答案的框架，也就是确定二分区间和建立二分判断逻辑。  
1. **确定二分区间**：和的最大值最小，和不可能大于整个数列的和吧。和的最小值也不可能小于数列里的最大值吧。于是我们确立了上下区间。
2. **建立二分逻辑判断**：假如我说每段和的最大值是x，我该如何判断这个和是能达到的呢？  
    可以先思考一下，然后继续阅读  
    你发现只需要**贪心地**做分组，最后自能见分晓！具体逻辑如下：
    - 开始遍历数列，统计加和
    - 一旦某个数加上之后超过了x，就意味着前面这些数必须在此断开，才能满足每段和的最大值是x。于是我们断开，并且从下一项开始从零加和，如是重复。
    - 最后如果分出了多于M个组，意味着这个和太小了，分不出来。如果少于M个组，意味着M偏大，还有操作空间
*bingo*
那么我们开始愉悦地写代码：
#### 《裂数剑法》
``` python
def maxi_sum_section(n, m, a): # a 表示数列
    def can_divide(x): # 约定 False 表示x带入后不成立，需要更大的x
        sec_cnt, sec_sum = 1, 0 #分别表示分段数，分段和
        for i in a:
            sec_sum += i
            if sec_sum > x: # 原来这一段加上这个数超过限额了，就分段
                sec_sum = i # 新的一段和初始化为下一个数
                sec_cnt += 1 # 分段数+1
            if sec_cnt > m:
                return False
        return True
    
    left, right = max(a), sum(a)
    while left < right:
        mid = (left + right + 1) // 2  # 向上取整，避免死循环
        
        if can_divide(mid): # 约定了 False 是指 mid 值太小了找不到满足条件的情况
            right = mid  # 尝试更小的值
        else:
            left = mid - 1  # 尝试更大的值
    
    return left

```
## 总结 - 二分初步
经过这一章的介绍，相信你已经掌握了二分法在一些“最值、判定”类问题中的巧妙用法，其实这只是二分思想的基础应用而已。二分不仅仅能用在数字区间上，还能延伸到答案空间、甚至与其他算法结合解决更复杂的问题。

如果你觉得意犹未尽，敬请期待第二章，我们将会深入探讨二分的进阶玩法，包括二分答案的本质、如何发现二分、在“判定+构造”类问题中的妙用，以及与其他技巧（如前缀和、贪心、dp等）的组合应用。

步履不停，让我们第二章见！
*上面这一段当然是 ai 老师写的*
