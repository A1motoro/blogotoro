# 排序 - 1

**Published:** October 14, 2025
**Category:** Programming
**Read Time:** 8 min

排序是最经典的一类问题，作为对算法的第一次接触，我们今天初步走进排序的世界。  
我们把一个数组充满无序数字排列成有序的过程叫做排序。*这很显然，我的朋友*  
## 选择排序 $O(n^2)$
面对一个无序序列，选择排序这样运作：  
1. 遍历，找没最大的
2. 加到序列里，在原序列里删掉它
3. 循环直到新序列长度和原序列长度一样  
于是你得到了一个很赞的有序序列，这种算法的优势有：
- 好写
- 符合人类直觉
- 适合给入门新手理解算法
劣势有：
- **慢**
- 用了两个序列的空间  
非常简单的思路，我们简单地实现它：

```python
def selection_sort(arr):
    sorted_arr = []
    while len(sorted_arr) < len(arr):
        max = 0 # 假定所有数都是正整数
        for i in arr:
            if i > max:
                max = i
        arr.remove(max) # 删除第一个是这个值的这个元素

    return sorted_arr
```
当然，你会说，*啊啊啊我不知道remove()方法难道做不了了吗？？？？？？？？*对于这个问题，我们可以通过**标记**这些删除了的数。一个数如果处理过了，就`flag`为`False`，再一次遍历到它的时候，`flag`条件不触发，就会跳过它了。
```python
def selection_sort(arr):
    n = len(arr)
    flag = [False] * n  # 创建标记数组，全为False
    sorted_arr = []
    
    for _ in range(n):  # 需要执行n次选择
        max_value = float('-inf')
        max_index = -1
        
        # 在未标记的元素中找最大值
        for i in range(n):
            if not flag[i] and arr[i] > max_value:
                max_value = arr[i]
                max_index = i
        
        # 标记为已处理，并加入排序结果
        if max_index != -1:
            flag[max_index] = True
            sorted_arr.insert(0, max_value)  # 降序插入
    
    return sorted_arr
```
你可以把`arr`换成任意整数数组，就会得到降序（从大到小）的排序结果。如果想要升序排序（小到大），只要把 `insert(0, max_value)` 换成 `append(max_value)`，或者每次找最小的数插到末尾即可。
这一方法思想非常直观，但效率其实很低，时间复杂度约为 $O(n^2)$，实际使用时，多用于排序教学理解。

~不要告诉我你不会求一个序列的最大值哦~

## 插入排序 $O(n^2)$
就像你打扑克一样，每到手一张就把它放在比前面的小比后面的大的一个位置。如此一来每时每刻这个序列都是有序的。请看VCR：
```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        # 向左扫描，找到比key大的都向右移
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr

# 示例
nums = [5, 2, 9, 1, 6]
print(insertion_sort(nums))  # 输出: [1, 2, 5, 6, 9]
```
简化全部右移这一步可以用链表优化，这里不扩展讲了，有兴趣的同学自己学学。

## 冒泡排序 $O(n^2)$
冒泡排序其实像每个数像泡泡一样冒到它该在的位置  
1. **反复比较**：从头到尾，把相邻的两个元素两两相比。
2. **谁大谁往后**：如果前面的比后面的大，就交换它们的位置，让大的往后"冒"一个格子。
3. **每轮确定一个最大**：这样一轮下来，最大的数字就被“冒”到最后一位，像气泡一样浮出了数组水面。
4. **范围缩小**：下次只需在前面还没冒泡的部分继续重复比较——末尾的越来越多元素已经各就各位，不用管了。
5. **重复N-1轮**：每一轮确定一个当前未排序序列的最大值位置，直到所有泡泡都安稳浮上来，序列有序。  
我们以序列 [3, 4, 2, 1, 6] 为例，讲解冒泡排序的每一步细节（升序）：

初始序列: [3, 4, 2, 1, 6]

**第1轮**：
- 比较 3 和 4，无需交换，序列不变 [3, 4, 2, 1, 6]
- 比较 4 和 2，4>2，交换，序列变为 [3, 2, 4, 1, 6]
- 比较 4 和 1，4>1，交换，序列变为 [3, 2, 1, 4, 6]
- 比较 4 和 6，4<6，无需交换，序列 [3, 2, 1, 4, 6]
- 本轮结束，最大元素 6 已经"浮"到末尾

**第2轮**（只看前4个数）：因为第一轮完成后保证了最大的数一定在最右侧。
- 比较 3 和 2，3>2，交换，序列 [2, 3, 1, 4, 6]
- 比较 3 和 1，3>1，交换，序列 [2, 1, 3, 4, 6]
- 比较 3 和 4，3<4，无需交换，序列 [2, 1, 3, 4, 6]

**第3轮**（只看前3个数）：
- 比较 2 和 1，2>1，交换，序列 [1, 2, 3, 4, 6]
- 比较 2 和 3，2<3，无需交换，序列 [1, 2, 3, 4, 6]

**第4轮**（只看前2个数）：
- 比较 1 和 2，1<2，无需交换，序列 [1, 2, 3, 4, 6]

已经全部有序！每一轮最大的数都会“冒”到右侧有序的位置。

你可以用如下代码体验冒泡排序过程：
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # 提前结束优化
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr

nums = [3, 4, 2, 1, 6]
print(bubble_sort(nums))
# 输出: [1, 2, 3, 4, 6]
```


## 桶排序 $O(n)$
桶排序就是一个**传奇**！它是天才的想法！

咳咳！
桶排序是一种利用“分桶+计数”思想的排序算法。适合**数值范围已知且不大**的整数集合排序。

比如要对 0~9 的 10 个数排序，只要：

1. 开 10 个桶（可以用长度为 10 的数组），每个桶用来计数每种数字出现次数。
2. 统计每个数字出现了几次。
3. 按顺序把数字“倒”出来。

**示例：对 [2, 5, 3, 5, 7, 2, 8] 排序：**
1. 开桶 `bucket = [0]*10`
2. 扫一遍，遇到数字就把对应桶+1  
   2 出现2次，3出现1次，5出现2次，7出现1次，8出现1次  
   `bucket = [0,0,2,1,0,2,0,1,1,0]`
3. 按顺序把每种数从桶里依次取出来：  
   2,2,3,5,5,7,8

**代码如下：**
```python
def bucket_sort(arr, max_num):
    # 桶数组，长度 = 数据的最大值+1
    bucket = [0] * (max_num + 1)
    for num in arr:
        bucket[num] += 1
    res = []
    for num in range(len(bucket)):
        res.extend([num] * bucket[num])
    return res

nums = [2, 5, 3, 5, 7, 2, 8]
print(bucket_sort(nums, max_num=9))
# 输出: [2, 2, 3, 5, 5, 7, 8]
```
啊！老师老师，桶排序只需要走一遍循环，为什么不都用桶排序呢！  
老师阴沉的脸告诉你事情不大对：  
啊！孩子！老师告诉你，桶排序虽然时间复杂度是 O(n)，看起来很快，但它有很多限制：

**1. 空间复杂度高**
- 需要开一个长度为 `max_num + 1` 的数组
- 如果数据范围很大（比如 0~1000000），就要开 100万个桶
- 内存消耗巨大！

**2. 只适用于整数**
- 桶排序只能处理整数
- 浮点数、字符串等无法直接使用

**3. 数据范围必须已知且有限**
- 如果不知道最大值，就无法确定桶的数量
- 如果数据范围很大，空间开销会爆炸

**4. 数据分布不均匀时效率低**
- 如果大部分桶都是空的，浪费空间
- 比如只有 2 个数：1 和 1000000，却要开 100万个桶

但是你是天才，孩子！你想到，**可以不用一开始建好那么多桶，可以碰到了再建桶！**，而且在 Python 中，正好可以用**字典**解决。所以你想到了桶排序的简化版：
## 计数排序 $O(n + k)$
计数排序是桶排序的优化版本，它使用字典来动态存储每个数字的出现次数，避免了预分配大量空间的问题。

**聪明的你的核心思想：**
1. 统计每个数字的出现次数，但是不出现的我先不记录
2. 按数字大小顺序输出

**示例：对 [2, 5, 3, 5, 7, 2, 8] 排序：**
1. 统计：`{2: 2, 3: 1, 5: 2, 7: 1, 8: 1}`
2. 按顺序输出：2,2,3,5,5,7,8

请看VCT，不是，请看VCR：

```python
def counting_sort(arr):
    """
    计数排序（字典优化版）
    arr: 待排序数组
    不需要预知最大值，自动适应数据范围
    """
    # 创建计数字典，只为实际出现的数字开"桶"
    count = {}

    # 统计每个元素出现次数
    for num in arr:
        count[num] = count.get(num, 0) + 1

    # 按数字大小顺序重建数组
    result = []
    for num in sorted(count.keys()):  # 从小到大排序
        result.extend([num] * count[num])

    return result

# 示例
nums = [4, 2, 3, 1, 4, 2, 3]
sorted_nums = counting_sort(nums)
print(sorted_nums)  # [1, 2, 2, 3, 3, 4, 4]

# 优势：支持更大范围的数据，不需要预知max_val
nums2 = [100, 5, 200, 1, 100, 5, 300]
sorted_nums2 = counting_sort(nums2)
print(sorted_nums2)  # [1, 5, 5, 100, 100, 200, 300]
```

## 接下来我们向排序秘境的更深处探索咯！！！！上面的这些排序算法一般都无法满足算法竞赛的时间复杂度要求哦，请看第二章排序算法——进阶！






