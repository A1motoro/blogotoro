// Article loader utility for multilingual blog posts
// This file is auto-generated by init-articles.js
// Do not edit manually - run 'node init-articles.js' instead

import { useTranslation } from 'react-i18next';

const articleContents = {
  "zh": {
    "binary-1": "# 二分算法 第一节\r\n\r\n**Published:** October 14, 2025\r\n**Category:** Programming\r\n**Read Time:** 8 min\r\n\r\n二分是一个能让人充分感受到算法魅力的 first glance，今天我们从最基础的二分一路直上云霄！\r\n\r\n## 经典二分查找\r\n二分查找是最基础的二分算法，用于在**有序**数组中查找特定元素。\r\n- 每次都将搜索区间一分为二\r\n- 中值比较，确定下一次的搜索区间\r\n- 用递归更为方便\r\n- 时间复杂度O(log n)\r\n\r\n下面是一个经典模板：\r\n``` python\r\ndef binary_search(nums, target):\r\n    left, right = 0, len(nums) - 1\r\n    \r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        \r\n        if nums[mid] == target:\r\n            return mid\r\n        elif nums[mid] < target:\r\n            left = mid + 1\r\n        else:\r\n            right = mid - 1\r\n    \r\n    return -1  # 未找到\r\n```\r\n狗都能学会，你就学吧你就\r\n\r\n## 二分答案\r\n这是一个非常聪明的技巧！它的思想时当你想解决一个问题的时候，你对它的答案做二分。就像是不断地问自己，如果这题答案是5，计算发现`唔，应该比5大`，再进一步二分下一个搜索空间。对特定的一些问题，通常是求解**最大值最小**和**最小值最大**的问题时有效，因为这些问题可以提供二分中选择左区间还是右区间的判断。通常，这意味着求一个临界点。\r\n\r\n这种算法的代码模板:\r\n``` python\r\ndef binary_search_answer(left, right, check_func):\r\n    while left < right:\r\n        mid = (left + right + 1) // 2  # 向上取整，避免死循环\r\n        \r\n        if check_func(mid):\r\n            left = mid  # 尝试更大的值\r\n        else:\r\n            right = mid - 1  # 缩小范围\r\n    \r\n    return left\r\n```\r\n其中的 `check_func()` 函数用来根据题目要求判断上下区间，返回 bool 变量。\r\n\r\n我们用一个实例帮助理解：\r\n\r\n### 吃香蕉问题（LeetCode 875）\r\n\r\n#### 题目描述\r\n有 `n` 堆香蕉，第 `i` 堆有 `piles[i]` 根香蕉。守卫每小时会回来，你必须在 `h` 小时内吃完所有香蕉。\r\n\r\n每小时你可以选择一堆香蕉，吃掉 `k` 根（k是你选择的速度）。如果你选择的速度是 `k`，那么：\r\n- 对于一堆有 `x` 根香蕉，你需要 `ceil(x / k)` 小时吃完这堆\r\n\r\n问：最小的速度 `k` 是多少，才能在 `h` 小时内吃完所有香蕉？\r\n\r\nPS：`ceil()`函数在`math`库中，表示向上取整\r\n\r\n#### 示例\r\n```\r\n输入: piles = [3,6,7,11], h = 8\r\n输出: 4\r\n解释: 当速度k=4时：\r\n- 第1堆：ceil(3/4) = 1小时\r\n- 第2堆：ceil(6/4) = 2小时\r\n- 第3堆：ceil(7/4) = 2小时\r\n- 第4堆：ceil(11/4) = 3小时\r\n总计8小时，恰好能在8小时内吃完\r\n```\r\n#### 分析！\r\n乍一看，这题死活和二分扯不上关系，但是你敏锐地察觉到，要求的似乎是一个**临界点**，当然你可以吃很快的速度，秒了所有香蕉，但是你想优雅地在h小时内正好吃完它们，这就满足了二分答案的条件。\r\n你咂咂嘴，嗯~，那想一想如果我猜测我用速度`k1`吃它，我如何判断我接下来要搜索的速度范围时比`k1`大还是小呢？  \r\n你恍然大悟！如果h小时吃不完就说明吃的太慢，在比`k1`大的速度区间内二分。吃得完就说明不够优雅，去比`k1`小的速度区间二分。  \r\n*bingo*\r\n接下来要解决的就是答案范围，要对哪个范围进行初始的二分呢？可能的速度最大值和最小值是什么呢？  \r\n众所周知，一小时不能吃半根香蕉，于是最小值是`1`  \r\n又因为你每次只能吃某一堆（不能一小时内吃完这堆吃那堆），所以最大值是`max(piles)`。因为再大也没有意义了。  \r\n现在你的《二分答案心经》已修至小成，一个区区《香蕉掌法》的武决岂不是轻松拿下？\r\n#### 《香蕉掌法》\r\n\r\n```python\r\nimport math\r\n\r\ndef min_eating_speed(piles, h):\r\n    def can_eat_all(speed):\r\n        total_hours = 0\r\n        for pile in piles:\r\n            total_hours += math.ceil(pile / speed)\r\n        return total_hours <= h\r\n    \r\n    # 二分答案范围\r\n    left, right = 1, max(piles)\r\n    \r\n    while left < right:\r\n        mid = (left + right) // 2\r\n        \r\n        if can_eat_all(mid):\r\n            # 能吃完，尝试更小的速度\r\n            right = mid\r\n        else:\r\n            # 吃不完，需要更大的速度\r\n            left = mid + 1\r\n    \r\n    return left\r\n```\r\n神功已成，亟需出门游历，可以看看[洛谷-二分竞技场](https://www.luogu.com.cn/training/111)继续锻炼此二门神妙法则！在这里再分享一道更难的题\r\n### 数列分段 （Luogu P1182）\r\n#### 题目描述\r\n对于一个长度为N的正整数数列，要求分为M段，每段连续，且每段和的最大值最小。\r\n\r\n如数列`[4, 2, 4, 5, 1]`要分成`3`段，分成`[4, 2], [4, 5], [1]`时和的最大值是9，而分成`[4], [2, 4], [5, 1]`时和的最大值只有6。后者是更好的分段方法，也是题目的答案。\r\n\r\n输入第一行N，M。第二行包含N个非负整数，组成一个数列。\r\n输出一个正整数表示答案。\r\n#### 题目分析！\r\n题目输出不要求给出分组方法，而且题目很明确地说了**最大值最小**，你惊坐起！  \r\n我们来构建二分答案的框架，也就是确定二分区间和建立二分判断逻辑。  \r\n1. **确定二分区间**：和的最大值最小，和不可能大于整个数列的和吧。和的最小值也不可能小于数列里的最大值吧。于是我们确立了上下区间。\r\n2. **建立二分逻辑判断**：假如我说每段和的最大值是x，我该如何判断这个和是能达到的呢？  \r\n    可以先思考一下，然后继续阅读  \r\n    你发现只需要**贪心地**做分组，最后自能见分晓！具体逻辑如下：\r\n    - 开始遍历数列，统计加和\r\n    - 一旦某个数加上之后超过了x，就意味着前面这些数必须在此断开，才能满足每段和的最大值是x。于是我们断开，并且从下一项开始从零加和，如是重复。\r\n    - 最后如果分出了多于M个组，意味着这个和太小了，分不出来。如果少于M个组，意味着M偏大，还有操作空间\r\n*bingo*\r\n那么我们开始愉悦地写代码：\r\n#### 《裂数剑法》\r\n``` python\r\ndef maxi_sum_section(n, m, a): # a 表示数列\r\n    def can_divide(x): # 约定 False 表示x带入后不成立，需要更大的x\r\n        sec_cnt, sec_sum = 1, 0 #分别表示分段数，分段和\r\n        for i in a:\r\n            sec_sum += i\r\n            if sec_sum > x: # 原来这一段加上这个数超过限额了，就分段\r\n                sec_sum = i # 新的一段和初始化为下一个数\r\n                sec_cnt += 1 # 分段数+1\r\n            if sec_cnt > m:\r\n                return False\r\n        return True\r\n    \r\n    left, right = max(a), sum(a)\r\n    while left < right:\r\n        mid = (left + right + 1) // 2  # 向上取整，避免死循环\r\n        \r\n        if can_divide(mid): # 约定了 False 是指 mid 值太小了找不到满足条件的情况\r\n            right = mid  # 尝试更小的值\r\n        else:\r\n            left = mid - 1  # 尝试更大的值\r\n    \r\n    return left\r\n\r\n```\r\n## 总结 - 二分初步\r\n经过这一章的介绍，相信你已经掌握了二分法在一些“最值、判定”类问题中的巧妙用法，其实这只是二分思想的基础应用而已。二分不仅仅能用在数字区间上，还能延伸到答案空间、甚至与其他算法结合解决更复杂的问题。\r\n\r\n如果你觉得意犹未尽，敬请期待第二章，我们将会深入探讨二分的进阶玩法，包括二分答案的本质、如何发现二分、在“判定+构造”类问题中的妙用，以及与其他技巧（如前缀和、贪心、dp等）的组合应用。\r\n\r\n步履不停，让我们第二章见！\r\n*上面这一段当然是 ai 老师写的*\r\n",
    "hello-world": "# Hello World - 编程入门指南\r\n\r\n**Published:** December 25, 2024\r\n**Category:** Programming\r\n**Read Time:** 3 min\r\n\r\n## 引言\r\n\r\n\"你好，世界！\"是每个程序员学习编程时的第一步。这个简单的程序不仅仅是代码，更代表着你正式迈入编程世界的大门。\r\n\r\n## 什么是Hello World\r\n\r\nHello World程序是一个计算机程序，它在计算机屏幕上输出或显示\"Hello, World!\"这句话。这是一个展示编程语言基本语法的标准示例。\r\n\r\n### 为什么重要\r\n\r\n- **验证环境**: 确保编程环境正确配置\r\n- **学习语法**: 掌握语言的基本结构\r\n- **建立信心**: 完成第一个程序带来的成就感\r\n\r\n## 不同语言的实现\r\n\r\n### Python\r\n```python\r\ndef hello_world():\r\n    message = \"Hello, World!\"\r\n    print(message)\r\n    return message\r\n\r\n# 调用函数\r\nresult = hello_world()\r\n```\r\n\r\n### JavaScript\r\n```javascript\r\nfunction helloWorld() {\r\n    const message = \"Hello, World!\";\r\n    console.log(message);\r\n\r\n    // 也可以使用ES6语法\r\n    const greeting = `Hello, ${message.split(',')[1].trim()}!`;\r\n    console.log(greeting);\r\n\r\n    return message;\r\n}\r\n\r\n// 执行函数\r\nhelloWorld();\r\n```\r\n\r\n### Java\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        String message = \"Hello, World!\";\r\n        System.out.println(message);\r\n\r\n        // 对象示例\r\n        HelloWorld instance = new HelloWorld();\r\n        instance.displayMessage(message);\r\n    }\r\n\r\n    public void displayMessage(String msg) {\r\n        System.out.println(\"Message: \" + msg);\r\n    }\r\n}\r\n```\r\n\r\n### C++\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n\r\nclass HelloWorld {\r\nprivate:\r\n    std::string message;\r\n\r\npublic:\r\n    HelloWorld() : message(\"Hello, World!\") {}\r\n\r\n    void display() {\r\n        std::cout << message << std::endl;\r\n\r\n        // 使用循环示例\r\n        for (char c : message) {\r\n            if (c != ' ') {\r\n                std::cout << c;\r\n            }\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    HelloWorld hello;\r\n    hello.display();\r\n    return 0;\r\n}\r\n```\r\n\r\n## 编程学习建议\r\n\r\n### 1. 从基础开始\r\n不要急于求成，从最简单的程序入手。\r\n\r\n### 2. 多实践\r\n编程是一门实践性学科，多写代码、多调试。\r\n\r\n### 3. 学习思维方式\r\n编程不仅教你写代码，更重要的是培养逻辑思维。\r\n\r\n## 结语\r\n\r\n\"Hello, World!\"虽然简单，却承载着无限可能。从这里开始，你将开启一段精彩的编程之旅！\r\n\r\n祝你编程愉快！🚀\r\n",
    "syntax-candy-python": "# Python 中的语法糖\r\n\r\n**Published:** October 10, 2025\r\n**Category:** Programming\r\n**Read Time:** 12 min\r\n\r\n本文将要介绍几个 Python 中优雅的语法糖，熟练运用这些巧妙的语法糖可以让你的代码变得更加 Pythonic 哦！\r\n\r\n~有人要问了，语法糖是啥，我直接一手颁奖`a, b = b, a`就是Python最伟大的语法糖！~\r\n\r\n## Lambda 函数\r\n\r\nLambda 函数是 Python 中的**一次性**的、**匿名函数**。我们拿下面这个简单的小例子来讲清楚：\r\n```python\r\nsquare = lambda x: x ** 2\r\nprint(square(4)) # 输出 16\r\n# 这等价于：\r\ndef square(x):\r\n    return x ** 2\r\n```\r\n为什么要多此一举搞这么一个一次性的函数呢？它最经常和优雅的应用是为复杂函数传参。\r\n\r\n请看VCR：  \r\n``` python\r\n# 假设我们有如下字典，要对他们按照value值排序\r\nd = {'apple': 2, 'banana': 1, 'cherry': 3}\r\nsorted_items = sorted(d.items(), key=lambda item: item[1])\r\n# 这里的 key 不是字典的键，而是sorted()的参数，告诉函数按照哪个值的大小来排序 \r\n```  \r\n注意到有个`lambda item: item[1]`，这就是 Lambda 函数。它的作用完全相当于：\r\n```python\r\ndef trans(dict.item):\r\n    return item[1]\r\n```\r\n不过后者可以反复调用，而Lambda 函数在一行内完成了函数的定义和调用，然后它就**无法被二次调用**了。\r\n\r\n它只支持单表达式，[三元表达式](#三元表达式)当然算单表达式了，请看VCR：\r\n```python\r\n# 这是一个三元表达式，是被允许的\r\nsign = lambda x: \"positive\" if x > 0 else \"negative\"\r\nprint(sign(5)) # 输出 positive\r\nprint(sign(-3)) # 输出，聪明的读者能想到吗？\r\n```\r\n要注意的是，Lambda 函数的**作用域**是它定义的那一行所在的作用域。\r\n\r\n*不建议把Lambda的参数名设置为当前作用域已经定义过的函数名*，语法上是允许的，但是语义上是危险的。\r\n\r\n> Lambda 函数在 Python 1.0 就已经被引入Python，所以在任何一个Python解释器上它都能正确运行！它基本上可以称得上是Python最古老的语法糖了。\r\n\r\n## 三元表达式\r\n\r\n**三元表达式**，或者**条件表达式**或者**三元运算符**，是 Python 2.5 版本引入的语法糖。它允许你将一个`if-else`逻辑压缩成一个表达式。它的语法结构如下：\r\n```python\r\nvalue_if_True if condition else value_if_False # 这是一个表达式\r\n```\r\n它会先判断condition成立与否，成立时表达式的值为前面，不成立就是后面。\r\n\r\n与C语言家族的三元表达式`condition? value_if_true : value_if_false`不同，需要注意。\r\n\r\n三元表达式当然**可以嵌套**，但是这并不被推荐，因为会乱到不知天地为何物。尝试读一下：\r\n```python\r\n# 根据分数返回等级\r\ngrade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'F'\r\n```  \r\n这时候，可以转身向`if-else`语句走去。或者，也可以看看[Match-Case](#Match-Case语法)。  \r\n\r\n## F-String 语法\r\n\r\n`f-string`中的 f 代表 formatted，这个语法帮助开发者十分轻松地格式化字符串，*简洁，高效，可读性强！*\r\n\r\n- **目的** 是将变量或表达式插入到字符串中间。\r\n- **本质** 不是一个字符串常量，而是一个运行时求值的**表达式**。\r\n\r\n语法结构如下：\r\n```python\r\nf\"字符串字符串字符串 {表达式} 后面还有字符串\" # f 大小写不影响\r\n```\r\n\r\n它支持所有Python表达式放进花括号里面，可以是函数调用、算数、方法，当然也可以放[三元表达式](#三元表达式)。\r\n\r\n它的性能优越，比`%`格式化和`str.format()`方法格式化更**快**。因为它在编译时解析。\r\n### 格式化选项\r\n大括号里面有很多格式化选项任君挑选，只需要你在花括号的表达式后加一个冒号`:`。\r\n\r\n- **浮点数精度** `{value:.2f}`表示保留两位小数，采用四舍五入。\r\n\r\n> Python 中的round()函数以及f-string中的保留小数都采用\"银行家舍入法\"，即**舍弃的数字恰好是5时**，如果前面一位是*偶数*，则**舍去**；是*奇数*，则*进位*。\r\n\r\n- 对齐与填充：`{value:>10}`表示右对齐，总宽度为10；`{value:<10}`无需多言；而`value:^10`表示居中对齐。\r\n\r\n- 转换标志：~自己学去，不教。~\r\n\r\n### 高级用法\r\n\r\n- 多行 f-string：用**三引号**创建多行 f-string，这里不展示了。\r\n- 解包字典，请看\r\n```python\r\ndata = {\"name\": \"Charlie\", \"score\": 95}\r\nprint(f\"Player {data['name']} scored {data['score']} points.\")\r\n# 或者\r\nprint(f\"Player {data['name']:>10} scored {data['score']} points.\")\r\n```\r\n- **引号有说法**：在 f-string 的表达式部分**不能**直接使用与外层字符串相同的引号，否则会引发语法错误。可以使用不同的引号或反斜杠转义。\r\n\r\n## 推导式\r\n\r\n这是 Python 中最具代表性的语法糖之一，用于简洁地初始化可迭代对象。它的**核心思想是将循环和条件逻辑压缩成一行表达式**。十分的简洁啊！\r\n\r\n### 先来看**列表推导式**：\r\n```python\r\n[expression for item in iterable]\r\n```\r\n这段代码会得到一个列表[]，每个元素是expression在迭代中算出来的元素。\r\n\r\n当然可以复杂一点，带一点条件：\r\n```python\r\n[expression for item in iterable if condition]\r\n```\r\n简单到无需说明！\r\n\r\n### 再来看看**字典推导式**\r\n\r\n与列表推导式类似，但需要**同时指定键和值的表达式**。\r\n```python\r\n{key_expression: value_expression for item in iterable if condition}\r\n```\r\n简单到无需说明！\r\n\r\n### 最后看看**集合表达式**\r\n\r\n~逗你的，我才不讲呢~\r\n\r\n咳咳，当然会讲的，我们先复习一下小学三年级学习的**集合**，无序且元素唯一是它的特性，所以再创建集合的时候会自动去除重复元素：\r\n```python\r\n{expression for item in iterable}\r\n```\r\n**总结**，声明性好强！写起来好爽！\r\n\r\n## 连续比较\r\n\r\n今天提到的所有语法糖中**最简单**的一个！将多个比较操作链接在一起，就像你写数学一样：\r\n```python\r\nif 1 < x < 10:\r\n    pass\r\n```\r\n\r\n在保证逻辑的情况下，可以这样写：\r\n```python\r\nif 1 < x > 0: # 总之就是两头都成立\r\n```\r\n\r\n不过，建议这种超级比较不要写。\r\n\r\n## Match-Case 语法\r\n\r\nMatch-Case语法则引入的晚了很多，它在 Python 3.10 版本引入。旨在简化复杂的`if-elif-else`语句链条。它的语法结构这么写：\r\n```python\r\nmatch subject:          # subject 是你要匹配的目标值\r\n    case <pattern_1>:   # 定义第一个模式\r\n        <action_1>      # 如果匹配，执行此动作\r\n    case <pattern_2>:   # 定义第二个模式\r\n        <action_2>      # 如果匹配，执行此动作\r\n    case _:             # 通配符模式，匹配任何值（可选）\r\n        <action_wildcard> # 如果以上都不匹配，执行此动作\r\n```\r\n它会从上往下遍历每一个case，**找到即停**，不会继续检查后面的case。\r\n\r\n等等，不是兄弟，**模式**是什么东西，看不懂啊？\r\n\r\n这就要说到它的强大特性**模式解构**功能了！它可以在匹配的同时，把符合的数据结构（比如元组、列表、字典）中的元素解包并赋值给变量。\r\n\r\n你说看不懂？那我们先看基础字面量的匹配，也就是先不用模式结构功能，模仿C语言中的`switch-case`语句。\r\n```python\r\nstatus_code = 418\r\n\r\nmatch status_code:\r\n    case 200:\r\n        print(\"Success\")\r\n    case 404 | 400: # | 表示或，就是这俩case用一个结果\r\n        print(\"Not Found\")\r\n    case 500:\r\n        print(\"Server Error\")\r\n    case _:  # 默认情况，通配符\r\n        print(f\"Unknown status: {status_code}\") # 刚刚学过的f-string语法糖，马上复习一下\r\n```\r\n\r\n再看看Python的**解包**能力，以解包字典为例，请看VCR：\r\n```python\r\nuser = {\"type\": \"admin\", \"level\": 5}\r\n\r\nmatch user:\r\n    case {\"type\": \"guest\"}:\r\n        print(\"Hello guest!\")\r\n    case {\"type\": \"user\", \"level\": level} if level < 3:\r\n        print(f\"Hello user, your level {level} is low.\")\r\n    case {\"type\": \"user\", \"level\": level}:\r\n        print(f\"Hello user, your level {level} is good.\")\r\n    case {\"type\": \"admin\", \"level\": level}:\r\n        print(f\"Hello admin! Level: {level}\") # 好多f-string，回忆一下\r\n```\r\n最后，这玩意是支持和if共存的，我们叫做**条件守卫**，可以再 case 后用 if 添加额外的条件。\r\n```python\r\nmatch command:\r\n    case [\"move\", direction, steps] if steps > 0:\r\n        print(f\"Moving {direction} for {steps} steps.\")\r\n    case [\"move\", _, steps] if steps <= 0:\r\n        print(\"Can't move zero or negative steps!\")\r\n```\r\n\r\n在`match-case`语法帮助下，我们能写出比`if-elif-else`清晰得多的代码，而且这种写法更**声明性**，更易读。\r\n\r\n## @ 装饰器\r\n\r\n装饰器是 Python 中最强大、最优雅的特性之一，它是一种设计模式，允许你在不修改原函数代码的前提下，动态地修改或增强一个函数或类的行为。主包也没完全学会，所以先讲一小段。\r\n\r\n我们现在遇到的最难理解的语法糖，我们从样例代码学起：\r\n```python\r\nimport time\r\nfrom functools import wraps\r\n\r\ndef timer(func):\r\n    \"\"\"\r\n    一个简单的计时装饰器。\r\n    \"\"\"\r\n    # @wraps(func) 用于保留原函数的元信息（如 __name__, __doc__）\r\n    @wraps(func)\r\n    def wrapper(*args, **kwargs): # 一个 * 打包成一个元组， ** 打包成一个字典\r\n        start = time.time()\r\n        # 调用原函数，并获取其返回值\r\n        result = func(*args, **kwargs)\r\n        end = time.time()\r\n        print(f\"{func.__name__} 执行耗时: {end - start:.4f} 秒\")\r\n        return result  # 必须返回原函数的结果\r\n    return wrapper\r\n\r\n# 使用装饰器\r\n@timer\r\ndef slow_function():\r\n    \"\"\"一个模拟耗时操作的函数\"\"\"\r\n    time.sleep(1)\r\n    return \"任务完成！\"\r\n\r\n# 调用被装饰的函数\r\nresult = slow_function()\r\nprint(result)\r\n# 输出:\r\n# slow_function 执行耗时: 1.00 秒\r\n# 任务完成！\r\n```\r\n其中`@timer`是语法糖，相当于`slow_function = timer(slow_function)`，`timer`函数接收`slow_function`作为参数`func`，然后在自己体内又定义了一个`wrapper`函数，其中加入了计时逻辑。\r\n\r\n学懂了吗？没关系，主包也是一知半解的。\r\n\r\n这玩意还能加参数，等主包学会了再写这一段！\r\n"
  },
  "en": {
    "binary-1": "# Binary Search Algorithm - Part 1\r\n\r\n**Published:** October 14, 2025\r\n**Category:** Programming\r\n**Read Time:** 8 min\r\n\r\nBinary search is a first glance that can make you fully appreciate the charm of algorithms. Today we'll start from the most basic binary search and go all the way to the clouds!\r\n\r\n## Classic Binary Search\r\n\r\nBinary search is the most fundamental binary algorithm, used to find a specific element in a **sorted** array.\r\n- Each time it halves the search interval\r\n- Compares the middle value and determines the next search interval\r\n- It's more convenient to use recursion\r\n- Time complexity is O(log n)\r\n\r\nHere's a classic template:\r\n``` python\r\ndef binary_search(nums, target):\r\n    left, right = 0, len(nums) - 1\r\n\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n\r\n        if nums[mid] == target:\r\n            return mid\r\n        elif nums[mid] < target:\r\n            left = mid + 1\r\n        else:\r\n            right = mid - 1\r\n\r\n    return -1  # Not found\r\n```\r\nEven a dog can learn it, so learn it!\r\n\r\n## Binary Search on Answer\r\n\r\nThis is a very clever technique! Its idea is that when you want to solve a problem, you do binary search on its answer. It's like constantly asking yourself, \"If the answer to this problem is 5, after calculating, it seems it should be bigger than 5\", then continue binary searching the next search space. For specific problems, it usually works for \"finding the maximum of the minimum\" and \"finding the minimum of the maximum\" problems, because these problems can provide the judgment of whether to choose the left interval or right interval in binary search. In short, this usually means finding a critical point.\r\n\r\nThe code template for this algorithm:\r\n``` python\r\ndef binary_search_answer(left, right, check_func):\r\n    while left < right:\r\n        mid = (left + right + 1) // 2  # Round up to avoid infinite loop\r\n\r\n        if check_func(mid):\r\n            left = mid  # Try a larger value\r\n        else:\r\n            right = mid - 1  # Narrow the range\r\n\r\n    return left\r\n```\r\nThe `check_func()` function is used to determine the upper and lower intervals according to the problem requirements, returning a bool variable.\r\n\r\nWe use an example to help understand:\r\n\r\n### Banana Eating Problem (LeetCode 875)\r\n\r\n#### Problem Description\r\nThere are `n` piles of bananas, the `i`th pile has `piles[i]` bananas. The guard comes back every hour, and you must finish eating all bananas within `h` hours.\r\n\r\nEvery hour you can choose one pile of bananas and eat `k` bananas (k is the speed you choose). So:\r\n- For a pile with `x` bananas, you need `ceil(x / k)` hours to finish eating this pile\r\n\r\nWhat's the minimum speed `k` so you can finish eating all bananas within `h` hours?\r\n\r\nPS: The `ceil()` function is in the `math` library, representing rounding up\r\n\r\n#### Example\r\n```\r\nInput: piles = [3,6,7,11], h = 8\r\nOutput: 4\r\nExplanation: When speed k=4:\r\n- 1st pile: ceil(3/4) = 1 hour\r\n- 2nd pile: ceil(6/4) = 2 hours\r\n- 3rd pile: ceil(7/4) = 2 hours\r\n- 4th pile: ceil(11/4) = 3 hours\r\nTotal 8 hours, exactly able to finish eating within 8 hours\r\n```\r\n\r\n#### Analysis!\r\nAt first glance, this problem has nothing to do with binary search, but you keenly realize that the required seems to be a **critical point**, of course you can eat at a very fast speed and finish all bananas instantly, but you want to elegantly finish eating them exactly within h hours, which satisfies the condition of binary search on answer.\r\nYou smack your lips, hmm~, so think about it, if I guess I eat at speed `k1`, how can I judge whether my next search speed range should be larger than `k1` or smaller?\r\nYou suddenly realize! If I can't finish eating in h hours, it means I'm eating too slowly, so I should search in the speed range larger than `k1`. If I can finish eating, it means it's not elegant enough, so I go to the speed range smaller than `k1` to search.\r\n*bingo*\r\nNext, I need to solve the range of answers, what range should I do the initial binary search on? What are the maximum and minimum possible speeds?\r\nObviously, you can't eat half a banana per hour, so the minimum is `1`\r\nAlso, because you can only eat one pile at a time (can't finish this pile and eat that pile in one hour), the maximum is `max(piles)`. Because any larger doesn't make sense.\r\nNow your \"Binary Search on Answer Heart Sutra\" has been cultivated to the elementary level, a mere \"Banana Palm Technique\" martial art shouldn't be difficult to take down?\r\n#### \"Banana Palm Technique\"\r\n\r\n```python\r\nimport math\r\n\r\ndef min_eating_speed(piles, h):\r\n    def can_eat_all(speed):\r\n        total_hours = 0\r\n        for pile in piles:\r\n            total_hours += math.ceil(pile / speed)\r\n        return total_hours <= h\r\n\r\n    # Binary search answer range\r\n    left, right = 1, max(piles)\r\n\r\n    while left < right:\r\n        mid = (left + right) // 2\r\n\r\n        if can_eat_all(mid):\r\n            # Can eat all, try smaller speed\r\n            right = mid\r\n        else:\r\n            # Can't eat all, need larger speed\r\n            left = mid + 1\r\n\r\n    return left\r\n```\r\nThe divine skill has been completed, time to go out and travel, you can continue practicing this miraculous technique at [Luogu Binary Arena](https://www.luogu.com.cn/training/111)! Here I'll share another harder problem\r\n### Sequence Segmentation (Luogu P1182)\r\n#### Problem Description\r\nFor a positive integer sequence of length N, divide it into M segments, each segment is continuous, and the maximum value of the sum of each segment is minimized.\r\n\r\nFor example, the sequence `[4, 2, 4, 5, 1]` is divided into `3` segments, when divided into `[4, 2], [4, 5], [1]`, the maximum sum is 9, while when divided into `[4], [2, 4], [5, 1]`, the maximum sum is only 6. The latter is a better segmentation method and is the answer to the problem.\r\n\r\nThe first line inputs N, M. The second line contains N non-negative integers forming a sequence.\r\nOutput a positive integer representing the answer.\r\n#### Problem Analysis!\r\nThe problem output doesn't require giving the grouping method, but the problem clearly states **minimize the maximum value**, you sit up in shock!\r\nWe build the framework of binary search on answer, that is, determine the binary search interval and establish the binary search judgment logic.\r\n1. **Determine binary search interval**: The maximum value of the sum can't be larger than the sum of the entire sequence, right. The minimum value of the sum can't be smaller than the maximum value in the sequence, right. So we establish the upper and lower bounds.\r\n2. **Establish binary search judgment logic**: Suppose I say the maximum sum of each segment is x, how can I judge if this sum can be achieved?\r\n    You can think about it first, then continue reading\r\n    You discover you only need to **greedily** do the grouping, the final result will speak for itself! The specific logic is as follows:\r\n    - Start traversing the sequence, accumulate the sum\r\n    - Once adding the next number would exceed x, it means the previous numbers must be cut off here to satisfy the maximum sum of each segment being x. So we cut off and start accumulating from zero from the next item, repeat.\r\n    - Finally, if more than M groups are divided, it means the sum is too small and can't be divided. If less than M groups, it means M is too large and there's still room for operation\r\n*bingo*\r\nNow we start writing code happily:\r\n#### \"Sequence Splitting Sword Technique\"\r\n``` python\r\ndef maxi_sum_section(n, m, a): # a represents the sequence\r\n    def can_divide(x): # Convention False means x doesn't hold after substitution, need larger x\r\n        sec_cnt, sec_sum = 1, 0 # Respectively represent segment count, segment sum\r\n        for i in a:\r\n            sec_sum += i\r\n            if sec_sum > x: # The original segment plus this number exceeds the limit, so segment\r\n                sec_sum = i # Initialize the sum of the new segment to the next number\r\n                sec_cnt += 1 # Segment count +1\r\n            if sec_cnt > m:\r\n                return False\r\n        return True\r\n\r\n    left, right = max(a), sum(a)\r\n    while left < right:\r\n        mid = (left + right + 1) // 2  # Round up to avoid infinite loop\r\n\r\n        if can_divide(mid): # Convention False means mid value is too small, can't find a situation that satisfies the condition\r\n            right = mid  # Try smaller value\r\n        else:\r\n            left = mid - 1  # Try larger value\r\n\r\n    return left\r\n\r\n```\r\n## Summary - Introduction to Binary Search\r\nThrough this section's introduction, I believe you've mastered the clever usage of binary search in some \"maximum-minimum\" and \"judgment\" type problems. However, this is just the basic application of binary search thinking. Binary search not only works on number intervals, but can also extend to answer spaces, and even combine with other algorithms to solve more complex problems.\r\n\r\nIf you feel unsatisfied, please look forward to the second chapter, where we'll delve into the advanced gameplay of binary search, including the essence of binary search on answer, how to discover binary search, its wonderful uses in \"judgment + construction\" type problems, and combinations with other techniques (such as prefix sums, greedy, dp, etc.).\r\n\r\nKeep moving forward, see you in chapter two!\r\n*That last paragraph was of course written by the AI teacher*\r\n\r\n",
    "hello-world": "# Hello World - A Programmer's First Step\r\n\r\n**Published:** December 25, 2024\r\n**Category:** Programming\r\n**Read Time:** 3 min\r\n\r\n## Introduction\r\n\r\n\"Hello, World!\" is the first step every programmer takes when learning to code. This simple program represents not just lines of code, but your official entry into the world of programming.\r\n\r\n## What is Hello World\r\n\r\nA Hello World program is a computer program that outputs or displays the message \"Hello, World!\" on a computer screen. It serves as a standard example to demonstrate the basic syntax of a programming language.\r\n\r\n### Why It Matters\r\n\r\n- **Environment Verification**: Ensures your programming environment is correctly configured\r\n- **Syntax Learning**: Master the basic structure of the language\r\n- **Confidence Building**: The sense of accomplishment from completing your first program\r\n\r\n## Implementation in Different Languages\r\n\r\n### Python\r\n```python\r\ndef hello_world():\r\n    message = \"Hello, World!\"\r\n    print(message)\r\n    return message\r\n\r\n# Call function\r\nresult = hello_world()\r\n```\r\n\r\n### JavaScript\r\n```javascript\r\nfunction helloWorld() {\r\n    const message = \"Hello, World!\";\r\n    console.log(message);\r\n\r\n    // ES6 syntax example\r\n    const greeting = `Hello, ${message.split(',')[1].trim()}!`;\r\n    console.log(greeting);\r\n\r\n    return message;\r\n}\r\n\r\n// Execute function\r\nhelloWorld();\r\n```\r\n\r\n### Java\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        String message = \"Hello, World!\";\r\n        System.out.println(message);\r\n\r\n        // Object example\r\n        HelloWorld instance = new HelloWorld();\r\n        instance.displayMessage(message);\r\n    }\r\n\r\n    public void displayMessage(String msg) {\r\n        System.out.println(\"Message: \" + msg);\r\n    }\r\n}\r\n```\r\n\r\n### C++\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n\r\nclass HelloWorld {\r\nprivate:\r\n    std::string message;\r\n\r\npublic:\r\n    HelloWorld() : message(\"Hello, World!\") {}\r\n\r\n    void display() {\r\n        std::cout << message << std::endl;\r\n\r\n        // Loop example\r\n        for (char c : message) {\r\n            if (c != ' ') {\r\n                std::cout << c;\r\n            }\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    HelloWorld hello;\r\n    hello.display();\r\n    return 0;\r\n}\r\n```\r\n\r\n## Programming Learning Tips\r\n\r\n### 1. Start with the Basics\r\nDon't rush to complex concepts. Begin with the simplest programs.\r\n\r\n### 2. Practice Regularly\r\nProgramming is a practical discipline. Write code, debug, and learn from mistakes.\r\n\r\n### 3. Learn the Mindset\r\nProgramming teaches you more than just writing code—it develops logical thinking.\r\n\r\n## Conclusion\r\n\r\nAlthough \"Hello, World!\" is simple, it holds infinite possibilities. From here, you will embark on an exciting programming journey!\r\n\r\nHappy coding! 🚀\r\n",
    "syntax-candy-python": "# Python Syntax Sugar\r\n\r\n**Published:** October 10, 2025\r\n**Category:** Programming\r\n**Read Time:** 12 min\r\n\r\nThis article will introduce several elegant syntax sugars in Python. Mastering these clever syntax sugars can make your code more Pythonic!\r\n\r\n~Someone asked, what is syntax sugar? I'll award `a, b = b, a` as Python's greatest syntax sugar right away!~\r\n\r\n## Lambda Functions\r\n\r\nLambda functions are **one-time**, **anonymous functions** in Python. Let's clarify this with a simple example below:\r\n```python\r\nsquare = lambda x: x ** 2\r\nprint(square(4)) # Output: 16\r\n# This is equivalent to:\r\ndef square(x):\r\n    return x ** 2\r\n```\r\nWhy go through all this trouble for a one-time function? Its most frequent and elegant application is passing parameters to complex functions.\r\n\r\nCheck out the VCR:\r\n```python\r\n# Assuming we have the following dictionary, sort them by value\r\nd = {'apple': 2, 'banana': 1, 'cherry': 3}\r\nsorted_items = sorted(d.items(), key=lambda item: item[1])\r\n# Here, key is not the dictionary key, but a parameter of sorted(), telling the function to sort by which value\r\n```\r\nNotice there's `lambda item: item[1]`, this is the Lambda function. Its function is completely equivalent to:\r\n```python\r\ndef trans(dict.item):\r\n    return item[1]\r\n```\r\nHowever, the latter can be called repeatedly, while the Lambda function completes function definition and calling in one line, then it **cannot be called again**.\r\n\r\nIt only supports single expressions, [ternary expressions](#ternary-expressions) of course count as single expressions, check out the VCR:\r\n```python\r\n# This is a ternary expression, it's allowed\r\nsign = lambda x: \"positive\" if x > 0 else \"negative\"\r\nprint(sign(5)) # Output: positive\r\nprint(sign(-3)) # Output: negative, what do smart readers think?\r\n```\r\nNote that the **scope** of Lambda functions is the line where they are defined.\r\n\r\n*It's not recommended to set Lambda parameter names to function names already defined in the current scope*. It's syntactically allowed, but semantically dangerous.\r\n\r\n> Lambda functions were introduced in Python 1.0, so they can run correctly on any Python interpreter! It can basically be considered Python's oldest syntax sugar.\r\n\r\n## Ternary Expressions\r\n\r\n**Ternary expressions**, or **conditional expressions** or **ternary operators**, are syntax sugar introduced in Python 2.5. They allow you to compress an `if-else` logic into an expression. Its syntax structure is as follows:\r\n```python\r\nvalue_if_True if condition else value_if_False # This is an expression\r\n```\r\nIt will first judge whether the condition is true, if true, the expression value is the front part, if false, it's the back part.\r\n\r\nDifferent from C family ternary expressions `condition? value_if_true : value_if_false`, note this.\r\n\r\nTernary expressions can of course be **nested**, but this is not recommended because it gets messy beyond recognition. Try reading:\r\n```python\r\n# Return grade based on score\r\ngrade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'F'\r\n```\r\nAt this time, you can turn to `if-else` statements. Or, you can also check out [Match-Case](#match-case-syntax).\r\n\r\n## F-String Syntax\r\n\r\nThe f in `f-string` stands for formatted, this syntax helps developers format strings very easily, *concise, efficient, and readable!*\r\n\r\n- **Purpose** is to insert variables or expressions into the middle of strings.\r\n- **Essence** is not a string constant, but an **expression** evaluated at runtime.\r\n\r\nThe syntax structure is as follows:\r\n```python\r\nf\"string string string {expression} more string after\" # f is case insensitive\r\n```\r\n\r\nIt supports all Python expressions inside curly braces, can be function calls, arithmetic, methods, of course can also put [ternary expressions](#ternary-expressions).\r\n\r\nIts performance is superior, **faster** than `%` formatting and `str.format()` method formatting. Because it's parsed at compile time.\r\n### Formatting Options\r\nThere are many formatting options to choose from inside the curly braces, just add a colon `:` after the expression in curly braces.\r\n\r\n- **Float precision** `{value:.2f}` means keep two decimal places, using rounding.\r\n\r\n> The round() function in Python and decimal keeping in f-string both use \"banker's rounding\", that is, **when the discarded digit is exactly 5**, if the previous digit is *even*, then **discard**; if *odd*, then *carry over*.\r\n\r\n- Alignment and padding: `{value:>10}` means right align, total width 10; `{value:<10}` self-explanatory; while `value:^10` means center align.\r\n\r\n- Conversion flags: ~Figure it out yourself, not teaching.~\r\n\r\n### Advanced Usage\r\n\r\n- Multi-line f-string: Create multi-line f-string with **triple quotes**, not shown here.\r\n- Unpack dictionary, see\r\n```python\r\ndata = {\"name\": \"Charlie\", \"score\": 95}\r\nprint(f\"Player {data['name']} scored {data['score']} points.\")\r\n# or\r\nprint(f\"Player {data['name']:>10} scored {data['score']} points.\")\r\n```\r\n- **Quote rules**: **Cannot** directly use quotes of the same type as the outer string in the expression part of f-string, otherwise it will cause syntax errors. Can use different quotes or backslash escaping.\r\n\r\n## Comprehensions\r\n\r\nThis is one of the most representative syntax sugars in Python, used to concisely initialize iterable objects. Its **core idea is to compress loop and conditional logic into one line expressions**. So concise!\r\n\r\n### First, let's look at **list comprehensions**:\r\n```python\r\n[expression for item in iterable]\r\n```\r\nThis code will get a list [], each element is the element calculated from expression in iteration.\r\n\r\nOf course can be more complex, with some conditions:\r\n```python\r\n[expression for item in iterable if condition]\r\n```\r\nSimple enough to need no explanation!\r\n\r\n### Next, let's look at **dictionary comprehensions**\r\n\r\nSimilar to list comprehensions, but need to **specify key and value expressions simultaneously**.\r\n```python\r\n{key_expression: value_expression for item in iterable if condition}\r\n```\r\nSimple enough to need no explanation!\r\n\r\n### Finally, let's look at **set comprehensions**\r\n\r\n~Tricking you, I'm not going to explain it~\r\n\r\n*Cough*, of course I'll explain, let's first review the **set** we learned in elementary school grade 3, its characteristic is unordered and unique elements, so duplicate elements are automatically removed when creating sets:\r\n```python\r\n{expression for item in iterable}\r\n```\r\n**Summary**, so declarative! So satisfying to write!\r\n\r\n## Chained Comparisons\r\n\r\nThe **simplest** one among all syntax sugars mentioned today! Link multiple comparison operations together, just like writing math:\r\n```python\r\nif 1 < x < 10:\r\n    pass\r\n```\r\n\r\nUnder guaranteed logic, you can write:\r\n```python\r\nif 1 < x > 0: # Anyway, both sides must be true\r\n```\r\n\r\nHowever, it's recommended not to write such super comparisons.\r\n\r\n## Match-Case Syntax\r\n\r\nMatch-Case syntax was introduced much later, it was introduced in Python 3.10. Aimed at simplifying complex `if-elif-else` statement chains. Its syntax structure is written like this:\r\n```python\r\nmatch subject:          # subject is the target value you're matching\r\n    case <pattern_1>:   # Define the first pattern\r\n        <action_1>      # If matched, execute this action\r\n    case <pattern_2>:   # Define the second pattern\r\n        <action_2>      # If matched, execute this action\r\n    case _:             # Wildcard pattern, matches any value (optional)\r\n        <action_wildcard> # If none above match, execute this action\r\n```\r\nIt will traverse each case from top to bottom, **stops when found**, won't continue checking cases below.\r\n\r\nWait, dude, what is a **pattern** thing, can't understand?\r\n\r\nThis brings us to its powerful feature **pattern destructuring**! It can unpack and assign variables to matching data structures (like tuples, lists, dictionaries) while matching.\r\n\r\nYou say you can't understand? Then let's first look at basic literal matching, that is, imitating C language's `switch-case` statements without pattern structure functions.\r\n```python\r\nstatus_code = 418\r\n\r\nmatch status_code:\r\n    case 200:\r\n        print(\"Success\")\r\n    case 404 | 400: # | means or, these two cases use one result\r\n        print(\"Not Found\")\r\n    case 500:\r\n        print(\"Server Error\")\r\n    case _:  # Default case, wildcard\r\n        print(f\"Unknown status: {status_code}\") # Just learned f-string syntax sugar, quick review\r\n```\r\n\r\nLet's also look at Python's **unpacking** capability, taking dictionary unpacking as an example, check VCR:\r\n```python\r\nuser = {\"type\": \"admin\", \"level\": 5}\r\n\r\nmatch user:\r\n    case {\"type\": \"guest\"}:\r\n        print(\"Hello guest!\")\r\n    case {\"type\": \"user\", \"level\": level} if level < 3:\r\n        print(f\"Hello user, your level {level} is low.\")\r\n    case {\"type\": \"user\", \"level\": level}:\r\n        print(f\"Hello user, your level {level} is good.\")\r\n    case {\"type\": \"admin\", \"level\": level}:\r\n        print(f\"Hello admin! Level: {level}\") # So many f-strings, recall\r\n```\r\nFinally, this thing supports coexisting with if, we call it **conditional guard**, you can add extra conditions with if after case.\r\n```python\r\nmatch command:\r\n    case [\"move\", direction, steps] if steps > 0:\r\n        print(f\"Moving {direction} for {steps} steps.\")\r\n    case [\"move\", _, steps] if steps <= 0:\r\n        print(\"Can't move zero or negative steps!\")\r\n```\r\n\r\nWith the help of `match-case` syntax, we can write much clearer code than `if-elif-else`, and this writing style is more **declarative**, more readable.\r\n\r\n## @ Decorators\r\n\r\nDecorators are one of Python's most powerful and elegant features, it's a design pattern that allows you to dynamically modify or enhance the behavior of a function or class without modifying the original function code. I haven't fully learned it either, so just a small section for now.\r\n\r\nThe most difficult syntax sugar we've encountered so far to understand, let's start with sample code:\r\n```python\r\nimport time\r\nfrom functools import wraps\r\n\r\ndef timer(func):\r\n    \"\"\"\r\n    A simple timing decorator.\r\n    \"\"\"\r\n    # @wraps(func) is used to preserve the original function's metadata (like __name__, __doc__)\r\n    @wraps(func)\r\n    def wrapper(*args, **kwargs): # One * packs into a tuple, ** packs into a dictionary\r\n        start = time.time()\r\n        # Call the original function and get its return value\r\n        result = func(*args, **kwargs)\r\n        end = time.time()\r\n        print(f\"{func.__name__} execution time: {end - start:.4f} seconds\")\r\n        return result  # Must return the original function's result\r\n    return wrapper\r\n\r\n# Use decorator\r\n@timer\r\ndef slow_function():\r\n    \"\"\"A function that simulates time-consuming operations\"\"\"\r\n    time.sleep(1)\r\n    return \"Task completed!\"\r\n\r\n# Call the decorated function\r\nresult = slow_function()\r\nprint(result)\r\n# Output:\r\n# slow_function execution time: 1.00 seconds\r\n# Task completed!\r\n```\r\nThe `@timer` here is syntax sugar, equivalent to `slow_function = timer(slow_function)`, the `timer` function receives `slow_function` as parameter `func`, then defines a `wrapper` function inside itself, adding timing logic to it.\r\n\r\nGot it? No worries, I haven't fully figured it out either.\r\n\r\nThis thing can also add parameters, wait until I learn it to write that section!\r\n"
  }
};

export const articleMetadata = {
  "binary-1": {
    "zh": {
      "title": "二分算法 第一节",
      "date": "October 14, 2025",
      "category": "Programming",
      "readTime": "8 min"
    },
    "en": {
      "title": "Binary Search Algorithm - Part 1",
      "date": "October 14, 2025",
      "category": "Programming",
      "readTime": "8 min"
    }
  },
  "hello-world": {
    "zh": {
      "title": "Hello World - 编程入门指南",
      "date": "December 25, 2024",
      "category": "Programming",
      "readTime": "3 min"
    },
    "en": {
      "title": "Hello World - A Programmer's First Step",
      "date": "December 25, 2024",
      "category": "Programming",
      "readTime": "3 min"
    }
  },
  "syntax-candy-python": {
    "zh": {
      "title": "Python 中的语法糖",
      "date": "October 10, 2025",
      "category": "Programming",
      "readTime": "12 min"
    },
    "en": {
      "title": "Python Syntax Sugar",
      "date": "October 10, 2025",
      "category": "Programming",
      "readTime": "12 min"
    }
  }
};

// Hook to get articles based on current language
export const useArticles = () => {
  const { i18n } = useTranslation();
  const currentLang = i18n.language;

  // Get featured and recent posts based on current language
  const getArticlesForLanguage = (lang) => {
    const effectiveLang = articleContents[lang] && Object.keys(articleContents[lang]).length > 0 ? lang : 'zh';

    return Object.keys(articleContents[effectiveLang] || {}).map(slug => ({
      id: slug,
      ...articleMetadata[slug][effectiveLang],
      icon: getIconForCategory(articleMetadata[slug][effectiveLang].category)
    }));
  };

  const getArticleContent = (slug) => {
    const lang = articleContents[currentLang] && articleContents[currentLang][slug] ? currentLang : 'zh';
    return articleContents[lang][slug];
  };

  const getArticleMetadata = (slug) => {
    const lang = articleMetadata[slug] && articleMetadata[slug][currentLang] ? currentLang : 'zh';
    return articleMetadata[slug][lang];
  };

  return {
    featuredPosts: getArticlesForLanguage(currentLang).filter(article => article.id === 'binary-1').slice(0, 1), // Binary search article as featured
    recentPosts: getArticlesForLanguage(currentLang),
    getArticleContent,
    getArticleMetadata,
    currentLanguage: currentLang
  };
};

// Helper function to get icon based on category
const getIconForCategory = (category) => {
  const iconMap = {
    '编程': 'fas fa-code',
    'Programming': 'fas fa-code',
    '数学': 'fas fa-file-alt',
    'Mathematics': 'fas fa-file-alt',
    '个人': 'fas fa-file-alt',
    'Personal': 'fas fa-file-alt',
    '测试': 'fas fa-file-alt',
    'Test': 'fas fa-file-alt'
  };
  return iconMap[category] || 'fas fa-file-alt';
};

export default useArticles;
