// Article loader utility for multilingual blog posts
// This file is auto-generated by init-articles.js
// Do not edit manually - run 'node init-articles.js' instead
/* eslint-disable no-template-curly-in-string */

import { useTranslation } from 'react-i18next';

// eslint-disable-next-line no-template-curly-in-string
const articleContents = {
  "zh": {
    "hello-world": "# Hello World - 编程入门指南\r\n\r\n**Published:** December 25, 2024\r\n**Category:** Programming\r\n**Read Time:** 3 min\r\n\r\n## 引言\r\n\r\n\"你好，世界！\"是每个程序员学习编程时的第一步。这个简单的程序不仅仅是代码，更代表着你正式迈入编程世界的大门。\r\n\r\n## 什么是Hello World\r\n\r\nHello World程序是一个计算机程序，它在计算机屏幕上输出或显示\"Hello, World!\"这句话。这是一个展示编程语言基本语法的标准示例。\r\n\r\n### 为什么重要\r\n\r\n- **验证环境**: 确保编程环境正确配置\r\n- **学习语法**: 掌握语言的基本结构\r\n- **建立信心**: 完成第一个程序带来的成就感\r\n\r\n## 不同语言的实现\r\n\r\n### Python\r\n```python\r\ndef hello_world():\r\n    message = \"Hello, World!\"\r\n    print(message)\r\n    return message\r\n\r\n# 调用函数\r\nresult = hello_world()\r\n```\r\n\r\n### JavaScript\r\n```javascript\r\nfunction helloWorld() {\r\n    const message = \"Hello, World!\";\r\n    console.log(message);\r\n\r\n    // 也可以使用ES6语法\r\n    // eslint-disable-next-line no-template-curly-in-string\r\n    const greeting = `Hello, ${message.split(',')[1].trim()}!`;\r\n    console.log(greeting);\r\n\r\n    return message;\r\n}\r\n\r\n// 执行函数\r\nhelloWorld();\r\n```\r\n\r\n### Java\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        String message = \"Hello, World!\";\r\n        System.out.println(message);\r\n\r\n        // 对象示例\r\n        HelloWorld instance = new HelloWorld();\r\n        instance.displayMessage(message);\r\n    }\r\n\r\n    public void displayMessage(String msg) {\r\n        System.out.println(\"Message: \" + msg);\r\n    }\r\n}\r\n```\r\n\r\n### C++\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n\r\nclass HelloWorld {\r\nprivate:\r\n    std::string message;\r\n\r\npublic:\r\n    HelloWorld() : message(\"Hello, World!\") {}\r\n\r\n    void display() {\r\n        std::cout << message << std::endl;\r\n\r\n        // 使用循环示例\r\n        for (char c : message) {\r\n            if (c != ' ') {\r\n                std::cout << c;\r\n            }\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    HelloWorld hello;\r\n    hello.display();\r\n    return 0;\r\n}\r\n```\r\n\r\n## 编程学习建议\r\n\r\n### 1. 从基础开始\r\n不要急于求成，从最简单的程序入手。\r\n\r\n### 2. 多实践\r\n编程是一门实践性学科，多写代码、多调试。\r\n\r\n### 3. 学习思维方式\r\n编程不仅教你写代码，更重要的是培养逻辑思维。\r\n\r\n## 结语\r\n\r\n\"Hello, World!\"虽然简单，却承载着无限可能。从这里开始，你将开启一段精彩的编程之旅！\r\n\r\n祝你编程愉快！🚀\r\n",
    "syntax-candy-python": "# Python 中的语法糖\r\n\r\n**Published:** October 10, 2025\r\n**Category:** Programming\r\n**Read Time:** TBD\r\n\r\n本文将要介绍几个 Python 中优雅的语法糖，熟练运用这些巧妙的语法糖可以让你的代码变得更加 Pythonic 哦！\r\n\r\n~有人要问了，语法糖是啥，我直接一手颁奖`a, b = b, a`就是Python最伟大的语法糖！~\r\n\r\n## Lambda 函数\r\n\r\nLambda 函数是 Python 中的**一次性**的、**匿名函数**。我们拿下面这个简单的小例子来讲清楚：\r\n```python\r\nsquare = lambda x: x ** 2\r\nprint(square(4)) # 输出 16\r\n# 这等价于：\r\ndef square(x):\r\n    return x ** 2\r\n```\r\n为什么要多此一举搞这么一个一次性的函数呢？它最经常和优雅的应用是为复杂函数传参。\r\n\r\n请看VCR：  \r\n``` python\r\n# 假设我们有如下字典，要对他们按照value值排序\r\nd = {'apple': 2, 'banana': 1, 'cherry': 3}\r\nsorted_items = sorted(d.items(), key=lambda item: item[1])\r\n# 这里的 key 不是字典的键，而是sorted()的参数，告诉函数按照哪个值的大小来排序 \r\n```  \r\n注意到有个`lambda item: item[1]`，这就是 Lambda 函数。它的作用完全相当于：\r\n```python\r\ndef trans(dict.item):\r\n    return item[1]\r\n```\r\n不过后者可以反复调用，而Lambda 函数在一行内完成了函数的定义和调用，然后它就**无法被二次调用**了。\r\n\r\n它只支持单表达式，[三元表达式](#三元表达式)当然算单表达式了，请看VCR：\r\n```python\r\n# 这是一个三元表达式，是被允许的\r\nsign = lambda x: \"positive\" if x > 0 else \"negative\"\r\nprint(sign(5)) # 输出 positive\r\nprint(sign(-3)) # 输出，聪明的读者能想到吗？\r\n```\r\n要注意的是，Lambda 函数的**作用域**是它定义的那一行所在的作用域。\r\n\r\n*不建议把Lambda的参数名设置为当前作用域已经定义过的函数名*，语法上是允许的，但是语义上是危险的。\r\n\r\n> Lambda 函数在 Python 1.0 就已经被引入Python，所以在任何一个Python解释器上它都能正确运行！它基本上可以称得上是Python最古老的语法糖了。\r\n\r\n## 三元表达式\r\n\r\n**三元表达式**，或者**条件表达式**或者**三元运算符**，是 Python 2.5 版本引入的语法糖。它允许你将一个`if-else`逻辑压缩成一个表达式。它的语法结构如下：\r\n```python\r\nvalue_if_True if condition else value_if_False # 这是一个表达式\r\n```\r\n它会先判断condition成立与否，成立时表达式的值为前面，不成立就是后面。\r\n\r\n与C语言家族的三元表达式`condition? value_if_true : value_if_false`不同，需要注意。\r\n\r\n三元表达式当然**可以嵌套**，但是这并不被推荐，因为会乱到不知天地为何物。尝试读一下：\r\n```python\r\n# 根据分数返回等级\r\ngrade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'F'\r\n```  \r\n这时候，可以转身向`if-else`语句走去。或者，也可以看看[Match-Case](#Match-Case语法)。  \r\n\r\n## F-String 语法\r\n\r\n`f-string`中的 f 代表 formatted，这个语法帮助开发者十分轻松地格式化字符串，*简洁，高效，可读性强！*\r\n\r\n- **目的** 是将变量或表达式插入到字符串中间。\r\n- **本质** 不是一个字符串常量，而是一个运行时求值的**表达式**。\r\n\r\n语法结构如下：\r\n```python\r\nf\"字符串字符串字符串 {表达式} 后面还有字符串\" # f 大小写不影响\r\n```\r\n\r\n它支持所有Python表达式放进花括号里面，可以是函数调用、算数、方法，当然也可以放[三元表达式](#三元表达式)。\r\n\r\n它的性能优越，比`%`格式化和`str.format()`方法格式化更**快**。因为它在编译时解析。\r\n### 格式化选项\r\n大括号里面有很多格式化选项任君挑选，只需要你在花括号的表达式后加一个冒号`:`。\r\n\r\n- **浮点数精度** `{value:.2f}`表示保留两位小数，采用四舍五入。\r\n\r\n> Python 中的round()函数以及f-string中的保留小数都采用\"银行家舍入法\"，即**舍弃的数字恰好是5时**，如果前面一位是*偶数*，则**舍去**；是*奇数*，则*进位*。\r\n\r\n- 对齐与填充：`{value:>10}`表示右对齐，总宽度为10；`{value:<10}`无需多言；而`value:^10`表示居中对齐。\r\n\r\n- 转换标志：~自己学去，不教。~\r\n\r\n### 高级用法\r\n\r\n- 多行 f-string：用**三引号**创建多行 f-string，这里不展示了。\r\n- 解包字典，请看\r\n```python\r\ndata = {\"name\": \"Charlie\", \"score\": 95}\r\nprint(f\"Player {data['name']} scored {data['score']} points.\")\r\n# 或者\r\nprint(f\"Player {data['name']:>10} scored {data['score']} points.\")\r\n```\r\n- **引号有说法**：在 f-string 的表达式部分**不能**直接使用与外层字符串相同的引号，否则会引发语法错误。可以使用不同的引号或反斜杠转义。\r\n\r\n## 推导式\r\n\r\n这是 Python 中最具代表性的语法糖之一，用于简洁地初始化可迭代对象。它的**核心思想是将循环和条件逻辑压缩成一行表达式**。十分的简洁啊！\r\n\r\n### 先来看**列表推导式**：\r\n```python\r\n[expression for item in iterable]\r\n```\r\n这段代码会得到一个列表[]，每个元素是expression在迭代中算出来的元素。\r\n\r\n当然可以复杂一点，带一点条件：\r\n```python\r\n[expression for item in iterable if condition]\r\n```\r\n简单到无需说明！\r\n\r\n### 再来看看**字典推导式**\r\n\r\n与列表推导式类似，但需要**同时指定键和值的表达式**。\r\n```python\r\n{key_expression: value_expression for item in iterable if condition}\r\n```\r\n简单到无需说明！\r\n\r\n### 最后看看**集合表达式**\r\n\r\n~逗你的，我才不讲呢~\r\n\r\n咳咳，当然会讲的，我们先复习一下小学三年级学习的**集合**，无序且元素唯一是它的特性，所以再创建集合的时候会自动去除重复元素：\r\n```python\r\n{expression for item in iterable}\r\n```\r\n**总结**，声明性好强！写起来好爽！\r\n\r\n## 连续比较\r\n\r\n今天提到的所有语法糖中**最简单**的一个！将多个比较操作链接在一起，就像你写数学一样：\r\n```python\r\nif 1 < x < 10:\r\n    pass\r\n```\r\n\r\n在保证逻辑的情况下，可以这样写：\r\n```python\r\nif 1 < x > 0: # 总之就是两头都成立\r\n```\r\n\r\n不过，建议这种超级比较不要写。\r\n\r\n## Match-Case 语法\r\n\r\nMatch-Case语法则引入的晚了很多，它在 Python 3.10 版本引入。旨在简化复杂的`if-elif-else`语句链条。它的语法结构这么写：\r\n```python\r\nmatch subject:          # subject 是你要匹配的目标值\r\n    case <pattern_1>:   # 定义第一个模式\r\n        <action_1>      # 如果匹配，执行此动作\r\n    case <pattern_2>:   # 定义第二个模式\r\n        <action_2>      # 如果匹配，执行此动作\r\n    case _:             # 通配符模式，匹配任何值（可选）\r\n        <action_wildcard> # 如果以上都不匹配，执行此动作\r\n```\r\n它会从上往下遍历每一个case，**找到即停**，不会继续检查后面的case。\r\n\r\n等等，不是兄弟，**模式**是什么东西，看不懂啊？\r\n\r\n这就要说到它的强大特性**模式解构**功能了！它可以在匹配的同时，把符合的数据结构（比如元组、列表、字典）中的元素解包并赋值给变量。\r\n\r\n你说看不懂？那我们先看基础字面量的匹配，也就是先不用模式结构功能，模仿C语言中的`switch-case`语句。\r\n```python\r\nstatus_code = 418\r\n\r\nmatch status_code:\r\n    case 200:\r\n        print(\"Success\")\r\n    case 404 | 400: # | 表示或，就是这俩case用一个结果\r\n        print(\"Not Found\")\r\n    case 500:\r\n        print(\"Server Error\")\r\n    case _:  # 默认情况，通配符\r\n        print(f\"Unknown status: {status_code}\") # 刚刚学过的f-string语法糖，马上复习一下\r\n```\r\n\r\n再看看Python的**解包**能力，以解包字典为例，请看VCR：\r\n```python\r\nuser = {\"type\": \"admin\", \"level\": 5}\r\n\r\nmatch user:\r\n    case {\"type\": \"guest\"}:\r\n        print(\"Hello guest!\")\r\n    case {\"type\": \"user\", \"level\": level} if level < 3:\r\n        print(f\"Hello user, your level {level} is low.\")\r\n    case {\"type\": \"user\", \"level\": level}:\r\n        print(f\"Hello user, your level {level} is good.\")\r\n    case {\"type\": \"admin\", \"level\": level}:\r\n        print(f\"Hello admin! Level: {level}\") # 好多f-string，回忆一下\r\n```\r\n最后，这玩意是支持和if共存的，我们叫做**条件守卫**，可以再 case 后用 if 添加额外的条件。\r\n```python\r\nmatch command:\r\n    case [\"move\", direction, steps] if steps > 0:\r\n        print(f\"Moving {direction} for {steps} steps.\")\r\n    case [\"move\", _, steps] if steps <= 0:\r\n        print(\"Can't move zero or negative steps!\")\r\n```\r\n\r\n在`match-case`语法帮助下，我们能写出比`if-elif-else`清晰得多的代码，而且这种写法更**声明性**，更易读。\r\n\r\n## @ 装饰器\r\n\r\n装饰器是 Python 中最强大、最优雅的特性之一，它是一种设计模式，允许你在不修改原函数代码的前提下，动态地修改或增强一个函数或类的行为。主包也没完全学会，所以先讲一小段。\r\n\r\n我们现在遇到的最难理解的语法糖，我们从样例代码学起：\r\n```python\r\nimport time\r\nfrom functools import wraps\r\n\r\ndef timer(func):\r\n    \"\"\"\r\n    一个简单的计时装饰器。\r\n    \"\"\"\r\n    # @wraps(func) 用于保留原函数的元信息（如 __name__, __doc__）\r\n    @wraps(func)\r\n    def wrapper(*args, **kwargs): # 一个 * 打包成一个元组， ** 打包成一个字典\r\n        start = time.time()\r\n        # 调用原函数，并获取其返回值\r\n        result = func(*args, **kwargs)\r\n        end = time.time()\r\n        print(f\"{func.__name__} 执行耗时: {end - start:.4f} 秒\")\r\n        return result  # 必须返回原函数的结果\r\n    return wrapper\r\n\r\n# 使用装饰器\r\n@timer\r\ndef slow_function():\r\n    \"\"\"一个模拟耗时操作的函数\"\"\"\r\n    time.sleep(1)\r\n    return \"任务完成！\"\r\n\r\n# 调用被装饰的函数\r\nresult = slow_function()\r\nprint(result)\r\n# 输出:\r\n# slow_function 执行耗时: 1.00 秒\r\n# 任务完成！\r\n```\r\n其中`@timer`是语法糖，相当于`slow_function = timer(slow_function)`，`timer`函数接收`slow_function`作为参数`func`，然后在自己体内又定义了一个`wrapper`函数，其中加入了计时逻辑。\r\n\r\n学懂了吗？没关系，主包也是一知半解的。\r\n\r\n这玩意还能加参数，等主包学会了再写这一段！\r\n"
  },
  "en": {
    "hello-world": "# Hello World - A Programmer's First Step\r\n\r\n**Published:** December 25, 2024\r\n**Category:** Programming\r\n**Read Time:** 3 min\r\n\r\n## Introduction\r\n\r\n\"Hello, World!\" is the first step every programmer takes when learning to code. This simple program represents not just lines of code, but your official entry into the world of programming.\r\n\r\n## What is Hello World\r\n\r\nA Hello World program is a computer program that outputs or displays the message \"Hello, World!\" on a computer screen. It serves as a standard example to demonstrate the basic syntax of a programming language.\r\n\r\n### Why It Matters\r\n\r\n- **Environment Verification**: Ensures your programming environment is correctly configured\r\n- **Syntax Learning**: Master the basic structure of the language\r\n- **Confidence Building**: The sense of accomplishment from completing your first program\r\n\r\n## Implementation in Different Languages\r\n\r\n### Python\r\n```python\r\ndef hello_world():\r\n    message = \"Hello, World!\"\r\n    print(message)\r\n    return message\r\n\r\n# Call function\r\nresult = hello_world()\r\n```\r\n\r\n### JavaScript\r\n```javascript\r\nfunction helloWorld() {\r\n    const message = \"Hello, World!\";\r\n    console.log(message);\r\n\r\n    // ES6 syntax example\r\n    // eslint-disable-next-line no-template-curly-in-string\r\n    const greeting = `Hello, ${message.split(',')[1].trim()}!`;\r\n    console.log(greeting);\r\n\r\n    return message;\r\n}\r\n\r\n// Execute function\r\nhelloWorld();\r\n```\r\n\r\n### Java\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        String message = \"Hello, World!\";\r\n        System.out.println(message);\r\n\r\n        // Object example\r\n        HelloWorld instance = new HelloWorld();\r\n        instance.displayMessage(message);\r\n    }\r\n\r\n    public void displayMessage(String msg) {\r\n        System.out.println(\"Message: \" + msg);\r\n    }\r\n}\r\n```\r\n\r\n### C++\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n\r\nclass HelloWorld {\r\nprivate:\r\n    std::string message;\r\n\r\npublic:\r\n    HelloWorld() : message(\"Hello, World!\") {}\r\n\r\n    void display() {\r\n        std::cout << message << std::endl;\r\n\r\n        // Loop example\r\n        for (char c : message) {\r\n            if (c != ' ') {\r\n                std::cout << c;\r\n            }\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    HelloWorld hello;\r\n    hello.display();\r\n    return 0;\r\n}\r\n```\r\n\r\n## Programming Learning Tips\r\n\r\n### 1. Start with the Basics\r\nDon't rush to complex concepts. Begin with the simplest programs.\r\n\r\n### 2. Practice Regularly\r\nProgramming is a practical discipline. Write code, debug, and learn from mistakes.\r\n\r\n### 3. Learn the Mindset\r\nProgramming teaches you more than just writing code—it develops logical thinking.\r\n\r\n## Conclusion\r\n\r\nAlthough \"Hello, World!\" is simple, it holds infinite possibilities. From here, you will embark on an exciting programming journey!\r\n\r\nHappy coding! 🚀\r\n",
    "syntax-candy-python": "# Python Syntax Sugar\r\n\r\n**Published:** October 10, 2025\r\n**Category:** Programming\r\n**Read Time:** TBD\r\n\r\nThis article will introduce several elegant syntax sugars in Python. Mastering these clever syntax sugars can make your code more Pythonic!\r\n\r\n~Someone asked, what is syntax sugar? I'll award `a, b = b, a` as Python's greatest syntax sugar right away!~\r\n\r\n## Lambda Functions\r\n\r\nLambda functions are **one-time**, **anonymous functions** in Python. Let's clarify this with a simple example below:\r\n```python\r\nsquare = lambda x: x ** 2\r\nprint(square(4)) # Output: 16\r\n# This is equivalent to:\r\ndef square(x):\r\n    return x ** 2\r\n```\r\nWhy go through all this trouble for a one-time function? Its most frequent and elegant application is passing parameters to complex functions.\r\n\r\nCheck out the VCR:\r\n```python\r\n# Assuming we have the following dictionary, sort them by value\r\nd = {'apple': 2, 'banana': 1, 'cherry': 3}\r\nsorted_items = sorted(d.items(), key=lambda item: item[1])\r\n# Here, key is not the dictionary key, but a parameter of sorted(), telling the function to sort by which value\r\n```\r\nNotice there's `lambda item: item[1]`, this is the Lambda function. Its function is completely equivalent to:\r\n```python\r\ndef trans(dict.item):\r\n    return item[1]\r\n```\r\nHowever, the latter can be called repeatedly, while the Lambda function completes function definition and calling in one line, then it **cannot be called again**.\r\n\r\nIt only supports single expressions, [ternary expressions](#ternary-expressions) of course count as single expressions, check out the VCR:\r\n```python\r\n# This is a ternary expression, it's allowed\r\nsign = lambda x: \"positive\" if x > 0 else \"negative\"\r\nprint(sign(5)) # Output: positive\r\nprint(sign(-3)) # Output: negative, what do smart readers think?\r\n```\r\nNote that the **scope** of Lambda functions is the line where they are defined.\r\n\r\n*It's not recommended to set Lambda parameter names to function names already defined in the current scope*. It's syntactically allowed, but semantically dangerous.\r\n\r\n> Lambda functions were introduced in Python 1.0, so they can run correctly on any Python interpreter! It can basically be considered Python's oldest syntax sugar.\r\n\r\n## Ternary Expressions\r\n\r\n**Ternary expressions**, or **conditional expressions** or **ternary operators**, are syntax sugar introduced in Python 2.5. They allow you to compress an `if-else` logic into an expression. Its syntax structure is as follows:\r\n```python\r\nvalue_if_True if condition else value_if_False # This is an expression\r\n```\r\nIt will first judge whether the condition is true, if true, the expression value is the front part, if false, it's the back part.\r\n\r\nDifferent from C family ternary expressions `condition? value_if_true : value_if_false`, note this.\r\n\r\nTernary expressions can of course be **nested**, but this is not recommended because it gets messy beyond recognition. Try reading:\r\n```python\r\n# Return grade based on score\r\ngrade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'F'\r\n```\r\nAt this time, you can turn to `if-else` statements. Or, you can also check out [Match-Case](#match-case-syntax).\r\n\r\n## F-String Syntax\r\n\r\nThe f in `f-string` stands for formatted, this syntax helps developers format strings very easily, *concise, efficient, and readable!*\r\n\r\n- **Purpose** is to insert variables or expressions into the middle of strings.\r\n- **Essence** is not a string constant, but an **expression** evaluated at runtime.\r\n\r\nThe syntax structure is as follows:\r\n```python\r\nf\"string string string {expression} more string after\" # f is case insensitive\r\n```\r\n\r\nIt supports all Python expressions inside curly braces, can be function calls, arithmetic, methods, of course can also put [ternary expressions](#ternary-expressions).\r\n\r\nIts performance is superior, **faster** than `%` formatting and `str.format()` method formatting. Because it's parsed at compile time.\r\n### Formatting Options\r\nThere are many formatting options to choose from inside the curly braces, just add a colon `:` after the expression in curly braces.\r\n\r\n- **Float precision** `{value:.2f}` means keep two decimal places, using rounding.\r\n\r\n> The round() function in Python and decimal keeping in f-string both use \"banker's rounding\", that is, **when the discarded digit is exactly 5**, if the previous digit is *even*, then **discard**; if *odd*, then *carry over*.\r\n\r\n- Alignment and padding: `{value:>10}` means right align, total width 10; `{value:<10}` self-explanatory; while `value:^10` means center align.\r\n\r\n- Conversion flags: ~Figure it out yourself, not teaching.~\r\n\r\n### Advanced Usage\r\n\r\n- Multi-line f-string: Create multi-line f-string with **triple quotes**, not shown here.\r\n- Unpack dictionary, see\r\n```python\r\ndata = {\"name\": \"Charlie\", \"score\": 95}\r\nprint(f\"Player {data['name']} scored {data['score']} points.\")\r\n# or\r\nprint(f\"Player {data['name']:>10} scored {data['score']} points.\")\r\n```\r\n- **Quote rules**: **Cannot** directly use quotes of the same type as the outer string in the expression part of f-string, otherwise it will cause syntax errors. Can use different quotes or backslash escaping.\r\n\r\n## Comprehensions\r\n\r\nThis is one of the most representative syntax sugars in Python, used to concisely initialize iterable objects. Its **core idea is to compress loop and conditional logic into one line expressions**. So concise!\r\n\r\n### First, let's look at **list comprehensions**:\r\n```python\r\n[expression for item in iterable]\r\n```\r\nThis code will get a list [], each element is the element calculated from expression in iteration.\r\n\r\nOf course can be more complex, with some conditions:\r\n```python\r\n[expression for item in iterable if condition]\r\n```\r\nSimple enough to need no explanation!\r\n\r\n### Next, let's look at **dictionary comprehensions**\r\n\r\nSimilar to list comprehensions, but need to **specify key and value expressions simultaneously**.\r\n```python\r\n{key_expression: value_expression for item in iterable if condition}\r\n```\r\nSimple enough to need no explanation!\r\n\r\n### Finally, let's look at **set comprehensions**\r\n\r\n~Tricking you, I'm not going to explain it~\r\n\r\n*Cough*, of course I'll explain, let's first review the **set** we learned in elementary school grade 3, its characteristic is unordered and unique elements, so duplicate elements are automatically removed when creating sets:\r\n```python\r\n{expression for item in iterable}\r\n```\r\n**Summary**, so declarative! So satisfying to write!\r\n\r\n## Chained Comparisons\r\n\r\nThe **simplest** one among all syntax sugars mentioned today! Link multiple comparison operations together, just like writing math:\r\n```python\r\nif 1 < x < 10:\r\n    pass\r\n```\r\n\r\nUnder guaranteed logic, you can write:\r\n```python\r\nif 1 < x > 0: # Anyway, both sides must be true\r\n```\r\n\r\nHowever, it's recommended not to write such super comparisons.\r\n\r\n## Match-Case Syntax\r\n\r\nMatch-Case syntax was introduced much later, it was introduced in Python 3.10. Aimed at simplifying complex `if-elif-else` statement chains. Its syntax structure is written like this:\r\n```python\r\nmatch subject:          # subject is the target value you're matching\r\n    case <pattern_1>:   # Define the first pattern\r\n        <action_1>      # If matched, execute this action\r\n    case <pattern_2>:   # Define the second pattern\r\n        <action_2>      # If matched, execute this action\r\n    case _:             # Wildcard pattern, matches any value (optional)\r\n        <action_wildcard> # If none above match, execute this action\r\n```\r\nIt will traverse each case from top to bottom, **stops when found**, won't continue checking cases below.\r\n\r\nWait, dude, what is a **pattern** thing, can't understand?\r\n\r\nThis brings us to its powerful feature **pattern destructuring**! It can unpack and assign variables to matching data structures (like tuples, lists, dictionaries) while matching.\r\n\r\nYou say you can't understand? Then let's first look at basic literal matching, that is, imitating C language's `switch-case` statements without pattern structure functions.\r\n```python\r\nstatus_code = 418\r\n\r\nmatch status_code:\r\n    case 200:\r\n        print(\"Success\")\r\n    case 404 | 400: # | means or, these two cases use one result\r\n        print(\"Not Found\")\r\n    case 500:\r\n        print(\"Server Error\")\r\n    case _:  # Default case, wildcard\r\n        print(f\"Unknown status: {status_code}\") # Just learned f-string syntax sugar, quick review\r\n```\r\n\r\nLet's also look at Python's **unpacking** capability, taking dictionary unpacking as an example, check VCR:\r\n```python\r\nuser = {\"type\": \"admin\", \"level\": 5}\r\n\r\nmatch user:\r\n    case {\"type\": \"guest\"}:\r\n        print(\"Hello guest!\")\r\n    case {\"type\": \"user\", \"level\": level} if level < 3:\r\n        print(f\"Hello user, your level {level} is low.\")\r\n    case {\"type\": \"user\", \"level\": level}:\r\n        print(f\"Hello user, your level {level} is good.\")\r\n    case {\"type\": \"admin\", \"level\": level}:\r\n        print(f\"Hello admin! Level: {level}\") # So many f-strings, recall\r\n```\r\nFinally, this thing supports coexisting with if, we call it **conditional guard**, you can add extra conditions with if after case.\r\n```python\r\nmatch command:\r\n    case [\"move\", direction, steps] if steps > 0:\r\n        print(f\"Moving {direction} for {steps} steps.\")\r\n    case [\"move\", _, steps] if steps <= 0:\r\n        print(\"Can't move zero or negative steps!\")\r\n```\r\n\r\nWith the help of `match-case` syntax, we can write much clearer code than `if-elif-else`, and this writing style is more **declarative**, more readable.\r\n\r\n## @ Decorators\r\n\r\nDecorators are one of Python's most powerful and elegant features, it's a design pattern that allows you to dynamically modify or enhance the behavior of a function or class without modifying the original function code. I haven't fully learned it either, so just a small section for now.\r\n\r\nThe most difficult syntax sugar we've encountered so far to understand, let's start with sample code:\r\n```python\r\nimport time\r\nfrom functools import wraps\r\n\r\ndef timer(func):\r\n    \"\"\"\r\n    A simple timing decorator.\r\n    \"\"\"\r\n    # @wraps(func) is used to preserve the original function's metadata (like __name__, __doc__)\r\n    @wraps(func)\r\n    def wrapper(*args, **kwargs): # One * packs into a tuple, ** packs into a dictionary\r\n        start = time.time()\r\n        # Call the original function and get its return value\r\n        result = func(*args, **kwargs)\r\n        end = time.time()\r\n        print(f\"{func.__name__} execution time: {end - start:.4f} seconds\")\r\n        return result  # Must return the original function's result\r\n    return wrapper\r\n\r\n# Use decorator\r\n@timer\r\ndef slow_function():\r\n    \"\"\"A function that simulates time-consuming operations\"\"\"\r\n    time.sleep(1)\r\n    return \"Task completed!\"\r\n\r\n# Call the decorated function\r\nresult = slow_function()\r\nprint(result)\r\n# Output:\r\n# slow_function execution time: 1.00 seconds\r\n# Task completed!\r\n```\r\nThe `@timer` here is syntax sugar, equivalent to `slow_function = timer(slow_function)`, the `timer` function receives `slow_function` as parameter `func`, then defines a `wrapper` function inside itself, adding timing logic to it.\r\n\r\nGot it? No worries, I haven't fully figured it out either.\r\n\r\nThis thing can also add parameters, wait until I learn it to write that section!\r\n"
  }
};

export const articleMetadata = {
  "hello-world": {
    "zh": {
      "title": "Hello World - 编程入门指南",
      "date": "December 25, 2024",
      "category": "Programming",
      "readTime": "3 min"
    },
    "en": {
      "title": "Hello World - A Programmer's First Step",
      "date": "December 25, 2024",
      "category": "Programming",
      "readTime": "3 min"
    }
  },
  "syntax-candy-python": {
    "zh": {
      "title": "Python 中的语法糖",
      "date": "October 10, 2025",
      "category": "Programming",
      "readTime": "TBD"
    },
    "en": {
      "title": "Python Syntax Sugar",
      "date": "October 10, 2025",
      "category": "Programming",
      "readTime": "TBD"
    }
  }
};

// Hook to get articles based on current language
export const useArticles = () => {
  const { i18n } = useTranslation();
  const currentLang = i18n?.language || 'zh'; // Fallback to 'zh' if i18n not ready

  // Safe helper functions with error handling
  const safeGetArticlesForLanguage = (lang) => {
    try {
      if (!articleContents || !articleMetadata) {
        return []; // Return empty array if data not loaded
      }

      const effectiveLang = articleContents[lang] && Object.keys(articleContents[lang]).length > 0 ? lang : 'zh';

      if (!articleContents[effectiveLang]) {
        return []; // Return empty array if language data not available
      }

      return Object.keys(articleContents[effectiveLang]).map(slug => {
        try {
          const metadata = articleMetadata[slug]?.[effectiveLang];
          if (!metadata) {
            return null; // Skip invalid articles
          }

          return {
            id: slug,
            ...metadata,
            icon: getIconForCategory(metadata.category)
          };
        } catch (error) {
          console.warn('Error processing article:', slug, error);
          return null;
        }
      }).filter(Boolean); // Remove null entries
    } catch (error) {
      console.warn('Error in getArticlesForLanguage:', error);
      return [];
    }
  };

  const getArticleContent = (slug) => {
    try {
      if (!slug || !articleContents) return '';
      const lang = articleContents[currentLang] && articleContents[currentLang][slug] ? currentLang : 'zh';
      return articleContents[lang]?.[slug] || '';
    } catch (error) {
      console.warn('Error getting article content:', slug, error);
      return '';
    }
  };

  const getArticleMetadata = (slug) => {
    try {
      if (!slug || !articleMetadata) return null;
      const lang = articleMetadata[slug] && articleMetadata[slug][currentLang] ? currentLang : 'zh';
      return articleMetadata[slug]?.[lang] || null;
    } catch (error) {
      console.warn('Error getting article metadata:', slug, error);
      return null;
    }
  };

  // Safe data retrieval
  const articles = safeGetArticlesForLanguage(currentLang);

  return {
    featuredPosts: articles.slice(0, 1), // First article as featured
    recentPosts: articles,
    getArticleContent,
    getArticleMetadata,
    currentLanguage: currentLang
  };
};

// Helper function to get icon based on category
const getIconForCategory = (category) => {
  const iconMap = {
    '编程': 'fas fa-code',
    'Programming': 'fas fa-code',
    '数学': 'fas fa-file-alt',
    'Mathematics': 'fas fa-file-alt',
    '个人': 'fas fa-file-alt',
    'Personal': 'fas fa-file-alt',
    '测试': 'fas fa-file-alt',
    'Test': 'fas fa-file-alt'
  };
  return iconMap[category] || 'fas fa-file-alt';
};

export default useArticles;
