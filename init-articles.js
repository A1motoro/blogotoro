#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Configuration
const POSTS_DIR = './blogii/posts';
const ZH_DIR = path.join(POSTS_DIR, 'zh');
const EN_DIR = path.join(POSTS_DIR, 'en');
const OUTPUT_FILE = './src/utils/articleLoader.js';

function parseMarkdownFrontmatter(content) {
  const lines = content.split('\n');
  const metadata = {};

  // Extract title from first heading
  const titleMatch = content.match(/^#\s+(.+)$/m);
  if (titleMatch) {
    metadata.title = titleMatch[1].trim();
  }

  // Extract metadata from **key:** value format
  const publishedMatch = content.match(/\*\*Published:\*\*\s*(.+)/);
  if (publishedMatch) {
    metadata.date = publishedMatch[1].trim();
  }

  const categoryMatch = content.match(/\*\*Category:\*\*\s*(.+)/);
  if (categoryMatch) {
    metadata.category = categoryMatch[1].trim();
  }

  const readTimeMatch = content.match(/\*\*Read Time:\*\*\s*(.+)/);
  if (readTimeMatch) {
    metadata.readTime = readTimeMatch[1].trim();
  }

  // Generate excerpt from first paragraph
  const paragraphs = content.split('\n\n').filter(p => p.trim() && !p.startsWith('#') && !p.includes('**Published:**'));
  if (paragraphs.length > 0) {
    metadata.excerpt = paragraphs[0].replace(/\*\*.*?\*\*/g, '').trim().substring(0, 150) + '...';
  }

  return metadata;
}

function generateSlug(filename) {
  return filename.replace(/\.md$/, '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
}

function processArticles() {
  const zhFiles = fs.readdirSync(ZH_DIR).filter(file => file.endsWith('.md'));
  const enFiles = fs.readdirSync(EN_DIR).filter(file => file.endsWith('.md'));

  const articles = {};
  const metadata = {};

  // Process Chinese articles
  zhFiles.forEach(file => {
    const slug = generateSlug(file);
    const filePath = path.join(ZH_DIR, file);
    const content = fs.readFileSync(filePath, 'utf8');

    articles.zh = articles.zh || {};
    articles.zh[slug] = content;

    metadata[slug] = metadata[slug] || {};
    metadata[slug].zh = parseMarkdownFrontmatter(content);
    metadata[slug].zh.title = metadata[slug].zh.title || slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  });

  // Process English articles
  enFiles.forEach(file => {
    const slug = generateSlug(file);
    const filePath = path.join(EN_DIR, file);
    const content = fs.readFileSync(filePath, 'utf8');

    articles.en = articles.en || {};
    articles.en[slug] = content;

    metadata[slug] = metadata[slug] || {};
    metadata[slug].en = parseMarkdownFrontmatter(content);
    metadata[slug].en.title = metadata[slug].en.title || slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  });

  return { articles, metadata };
}

function generateArticleLoader(articles, metadata) {
  const articleContentsStr = JSON.stringify(articles, null, 2);
  const metadataStr = JSON.stringify(metadata, null, 2);

  return `// Article loader utility for multilingual blog posts
// This file is auto-generated by init-articles.js
// Do not edit manually - run 'node init-articles.js' instead

import { useTranslation } from 'react-i18next';

const articleContents = ${articleContentsStr};

export const articleMetadata = ${metadataStr};

// Hook to get articles based on current language
export const useArticles = () => {
  const { i18n } = useTranslation();
  const currentLang = i18n.language;

  // Get featured and recent posts based on current language
  const getArticlesForLanguage = (lang) => {
    const effectiveLang = articleContents[lang] && Object.keys(articleContents[lang]).length > 0 ? lang : 'zh';

    return Object.keys(articleContents[effectiveLang] || {}).map(slug => ({
      id: slug,
      ...articleMetadata[slug][effectiveLang],
      icon: getIconForCategory(articleMetadata[slug][effectiveLang].category)
    }));
  };

  const getArticleContent = (slug) => {
    const lang = articleContents[currentLang] && articleContents[currentLang][slug] ? currentLang : 'zh';
    return articleContents[lang][slug];
  };

  const getArticleMetadata = (slug) => {
    const lang = articleMetadata[slug] && articleMetadata[slug][currentLang] ? currentLang : 'zh';
    return articleMetadata[slug][lang];
  };

  return {
    featuredPosts: getArticlesForLanguage(currentLang).slice(0, 1), // First article as featured
    recentPosts: getArticlesForLanguage(currentLang),
    getArticleContent,
    getArticleMetadata,
    currentLanguage: currentLang
  };
};

// Helper function to get icon based on category
const getIconForCategory = (category) => {
  const iconMap = {
    'ç¼–ç¨‹': 'fas fa-code',
    'Programming': 'fas fa-code',
    'æ•°å­¦': 'fas fa-file-alt',
    'Mathematics': 'fas fa-file-alt',
    'ä¸ªäºº': 'fas fa-file-alt',
    'Personal': 'fas fa-file-alt',
    'æµ‹è¯•': 'fas fa-file-alt',
    'Test': 'fas fa-file-alt'
  };
  return iconMap[category] || 'fas fa-file-alt';
};

export default useArticles;
`;
}

function main() {
  try {
    console.log('ğŸ” Scanning article folders...');

    // Check if directories exist
    if (!fs.existsSync(ZH_DIR)) {
      console.log('âŒ Chinese articles directory not found:', ZH_DIR);
      return;
    }
    if (!fs.existsSync(EN_DIR)) {
      console.log('âŒ English articles directory not found:', EN_DIR);
      return;
    }

    const { articles, metadata } = processArticles();

    console.log(`ğŸ“ Found ${Object.keys(metadata).length} article(s)`);

    // Generate the article loader file
    const content = generateArticleLoader(articles, metadata);
    fs.writeFileSync(OUTPUT_FILE, content, 'utf8');

    console.log('âœ… Article loader updated successfully!');
    console.log('ğŸ“ Output file:', OUTPUT_FILE);
    console.log('');
    console.log('ğŸš€ You can now run:');
    console.log('   npm start  # to preview your blog');
    console.log('   npm run build && npm run deploy  # to deploy');

  } catch (error) {
    console.error('âŒ Error processing articles:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}
